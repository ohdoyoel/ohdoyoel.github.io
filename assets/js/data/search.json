[ { "title": "C EXAMPLES: CLASS", "url": "/posts/class/", "categories": "Programming, C/C++", "tags": "c, c++", "date": "2022-06-15 16:48:06 +0900", "snippet": "필자의 대학 코스 Advanced Programming에서 사용된 예시를 발췌, 정리했습니다. FINAL 시험에서 좋은 성과를 바라며…Rectangle Classrectangle.h#ifndef RECTANGLE_H#define RECTANGLE_H#include &amp;lt;iostream&amp;gt;class rectangle { double width, height; // 멤버 변수public: rectangle(double w, double h) : width(w), height(h) {} // 생성자 double get_width() const { return this-&amp;gt;width; } // 멤버 함수 double get_height() const { return this-&amp;gt;height; } // 멤버 함수};std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;, rectangle const &amp;amp;);#endifrectangle.cpp#include &quot;rectangle.h&quot;using namespace std;ostream &amp;amp;operator&amp;lt;&amp;lt;(ostream &amp;amp;out, rectangle const &amp;amp;r) { return out &amp;lt;&amp;lt; &quot;rectangle (width:&quot; &amp;lt;&amp;lt; r.get_width() &amp;lt;&amp;lt; &quot;,height:&quot; &amp;lt;&amp;lt; r.get_height() &amp;lt;&amp;lt; &quot;)&quot;;}main.cpp#include &quot;rectangle.h&quot;#include &amp;lt;iostream&amp;gt;int main() { using namespace std; rectangle r(10, 5); cout &amp;lt;&amp;lt; r &amp;lt;&amp;lt; endl; return 0;}출력rectangle (width:10, height:5)Bank Account Classbank-account.h#ifndef BANK_ACCOUNT_H#define BANK_ACCOUNT_Hclass bank_account{ unsigned long balance;public: bank_account(unsigned long b=0) : balance(b) {} bank_account&amp;amp; operator+=(unsigned long); unsigned long get_balance() const { return this-&amp;gt;balance; } bool transfer_to(bank_account &amp;amp;, unsigned long );};#include &amp;lt;iostream&amp;gt;std::ostream&amp;amp; operator&amp;lt;&amp;lt;(std::ostream &amp;amp;, bank_account const &amp;amp;);#endifbank-account.cc#include &quot;bank-account.h&quot;bank_account&amp;amp; bank_account::operator+=(unsigned long amt){ this-&amp;gt;balance += amt; return *this;}bool bank_account::transfer_to(bank_account &amp;amp;other, unsigned long amt){ if (this-&amp;gt;balance &amp;gt;= amt) { this-&amp;gt;balance -= amt; // 여기는 되는 이유: 멤버 함수니까! other.balance += amt; return true; } else { return false; } }using namespace std;ostream&amp;amp; operator&amp;lt;&amp;lt;(ostream&amp;amp; out, bank_account const &amp;amp;accct){ return out &amp;lt;&amp;lt; &quot;Balance: &quot; &amp;lt;&amp;lt; acct.get_balance(); // 여기를 balance로 하면 안되는 이유: balances는 private 멤버 변수}main.cc#include &quot;bank-account.h&quot;#include &amp;lt;iostream&amp;gt;using namespace std;int main(){ bank_account a; bank_account b = 50; a += 100; b += 1000; if (!a.transfer_to(b, 1)) cerr &amp;lt;&amp;lt; &quot;could not transfer money&quot; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; b &amp;lt;&amp;lt; endl; return 0; }출력Balance: 99Balance: 1051Fraction Classfraction.h#ifndef FRACTION_H#define FRACTION_H#include &amp;lt;iostream&amp;gt;class fraction{ int num; unsigned denom;public: fraction(int num, unsigned denom=1) : num(num), denom(denom) {} // initializer list fraction(fraction const &amp;amp;f) : num(f.num), denom(f.denom) {} fraction&amp;amp; operator*=(fraction const &amp;amp;); fraction operator*(fraction const &amp;amp;) const; // 관습적으로 쪼개서 구현한다! / 뒤에 붙는 const는, 값을 읽어서 반환만 하므로 (수정하지 않으므로) const가 붙는다 fraction&amp;amp; operator+=(fraction const &amp;amp;); fraction operator+(fraction const &amp;amp;) const; fraction&amp;amp; operator-=(fraction cons &amp;amp;) { return *this += -other; } fraction operator-(fraction const &amp;amp;) const {return *this + -other; } fraction operator-() const { return fraction(-num, denom); } friend std::ostream&amp;amp; operator&amp;lt;&amp;lt;(std::ostream &amp;amp;, fraction const &amp;amp;); // 요친구는 fraction의 친구, 즉 fraction의 멤버 변수에 접근 가능};#endiffraction.cc#include &quot;fraction.h&quot;fraction&amp;amp; fraction::operator*=(fraction const &amp;amp;other){ this-&amp;gt;num *= other.num; this-&amp;gt;denom *= other.denom; return *this;}fraction fraction::operator*(fraction const &amp;amp;other) const{ fraction f = *this; // 복사 생성자 필요! return f *= other; // 최대한 위에 쓴 걸 활용하자}fraction&amp;amp; fraction::operator+=(fraction const &amp;amp;other) { unsigned new_denom = this-&amp;gt;denom * other.denom; this-&amp;gt;num = this-&amp;gt;num * other.denom + this-&amp;gt;denom * other.num; this-&amp;gt;denom = new_denom; return *this;}fraction fraction::operator+(fraction const &amp;amp;other) const { fraction f = *this; return f += other;}using namespace std;ostream&amp;amp; operator&amp;lt;&amp;lt;(ostream&amp;amp; out, fraction const &amp;amp;f){ return out &amp;lt;&amp;lt; f.num &amp;lt;&amp;lt; &quot;/&quot; &amp;lt;&amp;lt; f.denom;}main.cc#include &quot;fraction.h&quot;#include &amp;lt;iostream&amp;gt;using namespace std;int main(){ fraction f = -2; fraction g(5, 7); cout &amp;lt;&amp;lt; f &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; g &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; f * g &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; f * g - 1 &amp;lt;&amp;lt; endl; return 0; }출력-2/15/7-10/7-17/10Set Classset.h#ifndef SET_H#define SET_H#include &amp;lt;cstddef&amp;gt; // for size_tclass integer_set{ int* elements; size_t num_elements;public: integer_set(); ~integer_set() { delete [] this-&amp;gt;elements; } integer_set&amp;amp; operator+=(int); // insert an int into the set integer_set&amp;amp; operator-=(int); // remove an int from the set bool operator[](int) const; // 있는지 없는지 체크};#endifset.cc#include &quot;set.h&quot;integer_set::integer_set() : elements(new int[0]), num_elements(0) {}integer_set::integer_set(integer_set const &amp;amp;other) : elements(new int[other.num_elements]), num_elements(other.num_elements) { for (size_t i = 0; i &amp;lt; this-&amp;gt;num_elements; i++) this-&amp;gt;elements[i] = other.elements[i];}integer_set&amp;amp; integer_set::operator=(integer_set const &amp;amp;other) { if (this-&amp;gt;num_elements &amp;lt; other.num_elements) { delete [] this-&amp;gt;elements; this-&amp;gt;elements = new int[other.num_elements]; } this-&amp;gt;num_elements = other.num_elements; for (size_t i = 0; i &amp;lt; this-&amp;gt;num_elements; i++) this-&amp;gt;elements[i] = other.elements[i]; return *this;}integer_set&amp;amp; integer_set::operator+=(int val) { if ((*this)[val]) return *this; int* bigger = new int[this-&amp;gt;num_elements + 1]; for (size_t i = 0; i &amp;lt; this-&amp;gt;num_elements; i++) bigger[i] = this-&amp;gt;elements[i]; bigger[this-&amp;gt;num_elements] = val; delete [] this-&amp;gt;elements; this-&amp;gt;elements = bigger; this-&amp;gt;num_elements++; return *this;}integer_set&amp;amp; integer_set::operator-=(int val) { if (!(*this)[val]) return *this; int* val_location = this-&amp;gt;elements; for (size_t i = 0; i &amp;lt; this-&amp;gt;num_elements; i++) if (this-&amp;gt;elements[i] == val) val_location = &amp;amp;this-&amp;gt;elements[i]; *val_location = this-&amp;gt;elements[this-&amp;gt;num_elements - 1]; this-&amp;gt;num_elements--; return *this;}bool integer_set::operator[](int val) const { for (size_t i = 0; i &amp;lt; this-&amp;gt;num_elements; i++) if (this-&amp;gt;elements[i] == val) return true; return false;}main.cc#include &quot;set.h&quot;#include &amp;lt;iostream&amp;gt;int main() { using namespace std; integer_set s; s += 1; cout &amp;lt;&amp;lt; &quot;0 is in the set? &quot; &amp;lt;&amp;lt; s[0] &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &quot;1 is in the set? &quot; &amp;lt;&amp;lt; s[1] &amp;lt;&amp;lt; endl; integer_set t = s; t += 3; cout &amp;lt;&amp;lt; &quot;3 is in the set? &quot; &amp;lt;&amp;lt; t[3] &amp;lt;&amp;lt; endl; s = t; s += 2; cout &amp;lt;&amp;lt; &quot;2 is in the set? &quot; &amp;lt;&amp;lt; s[2] &amp;lt;&amp;lt; endl; return 0;}출력...가변 길이 TEMPLATE을 이용한 SUM FUNCTION가변 길이 템플릿의 구 버전#define SUM_FUNCTION(tp) tp sum_ ## tp(tp const* arr, size_t n) { \\ tp total = 0; \\ for (size_t i = 0; i &amp;lt; n; i++) \\ total += arr[i]; return total; }SUM_FUNCTION(int)sum.h#ifndef SUM_H#define SUM_H#include &amp;lt;cstddef&amp;gt;template &amp;lt;typename T&amp;gt; T sum(T const *, size_t);#include sum.cc#include &quot;sum.h&quot;template &amp;lt;typename T&amp;gt; T sum(T const *xs, size_t n){ T total = 0; for (size_t i = 0; i &amp;lt; n; i++) total += xs[i]; return total;}template int sum&amp;lt;int&amp;gt; (int const *, size_t);main.ccint main() { using namespace std; int x[] = { 3, 4, 5 }; cout &amp;lt;&amp;lt; sum&amp;lt;int&amp;gt;(x, 3) &amp;lt;&amp;lt; endl; double y[] = { 9.5, 10, 10.5 }; cout &amp;lt;&amp;lt; sum(y, 3) &amp;lt;&amp;lt; endl; value&amp;lt;double&amp;gt; a; cout &amp;lt;&amp;lt; a.get_value() &amp;lt;&amp;lt; endl; return 0;}출력...TEMPLATE을 이용한 LIST 클래스list.h#ifndef LIST_H#define LIST_H#include &amp;lt;cstddef&amp;gt; // for size_ttemplate&amp;lt;typename T&amp;gt;class list { T* elements; size_t num_elements;public: list() : elements(new T[0]), num_elements(0) {} // rule of 3 ~list() { delete [] elements; } list(list const &amp;amp;) : elements(new T[other.num_elements]), num_elements(other.num_elements) { for (size_t i = 0; i &amp;lt; this-&amp;gt;num_elements; i++) this-&amp;gt;elements[i] = other.elements[i]; } list&amp;amp; operator=(list const &amp;amp;){ delete [] elements; this-&amp;gt;num_elements = other.num_elements; this-&amp;gt;elements = new T[this-&amp;gt;num_elements]; for (size_t i = 0; i &amp;lt; this-&amp;gt;num_elements; i++) this-&amp;gt;elements[i] = other.elements[i]; return *this; } size_t length() const { return this-&amp;gt;num_elements; } T&amp;amp; operator[](size_t index) { if (index &amp;gt;= this-&amp;gt;num_elements) { T* new_elements = new T[index + 1]; for (size_t i = 0; i &amp;lt; this-&amp;gt;num_elements; i++) new_elements[i] = this-&amp;gt;elements[i]; delete [] this-&amp;gt;elements; this-&amp;gt;elements = new_elements; this-&amp;gt;num_elements = index + 1; } return this-&amp;gt;elements[index]; }};/* * list&amp;lt;int&amp;gt; l; * l[0] = 4; // adding something new to the list * l[0]++; // modifying something in the list * cout &amp;lt;&amp;lt; l[0] &amp;lt;&amp;lt; endl; // retrieving from the list */#endifmain.cc#include &amp;lt;iostream&amp;gt;#include &quot;list.h&quot;int main(){ using namespace std; list&amp;lt;int&amp;gt; l; l[0] = 4; l[0]++; l[3] = l[0] * 9; for (size_t i = 0; i &amp;lt; l.length(); i++) cout &amp;lt;&amp;lt; l[i] &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; endl; return 0;}STL:VECTOR 예시#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;int main(){ using namespace std; vector&amp;lt;int&amp;gt; v; v.push_back(2); v.push_back(3); cout &amp;lt;&amp;lt; v[0] &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; v[1] &amp;lt;&amp;lt; endl; for (int x : v) cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; endl; return 0;}INHERITANCE: SHAPE CLASSshape.cc#include &amp;lt;iostream&amp;gt;enum col {black, red, white};class shape{ col colour;public: shape(col c) : colour(c) {} virtual double area() const { return 0; } virtual double perimeter() const { return 0; }};class circle : public shape { double radius;public: circle(col c, double r) : shape(c), radius(r) {} virtual double area() const { return 3.14 * this-&amp;gt;radius * this-&amp;gt;radius; } virtual double perimeter() const { return 2 * 3.14 * this-&amp;gt;radius; }};class triangle : public shape { double base, height;public: triangle(col c, double b, double h) : shape(c), base(b), height(h) {} virtual double area() const { return this-&amp;gt;base * this-&amp;gt;height / 2; }};int main(){ using namespace std; triangle t(col::red, 3, 4); circle c(col::black, 5); //shape s = c; // 부모에 자식 대입은 불가능! shape&amp;amp; s = c; // 이건 가능 cout &amp;lt;&amp;lt; t.area() &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; c.area() &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; t.perimeter() &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; c.perimeter() &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; s.area() &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; s.perimeter() &amp;lt;&amp;lt; endl; // virtual이 있기 때문에 c에 대한 정보로 처리, 없으면 s로 처리 return 0;}NUMBER CLASSnumber.cc#include &amp;lt;iostream&amp;gt;using namespace std;class number {protected: virtual double real_value() const = 0; virtual double imaginary_value() const;public: virtual complex_number operator+(number const &amp;amp;other) const { double r = this-&amp;gt;real_value() + other.real_value(); double i = this-&amp;gt;imaginary_value() + other.imaginary_value(); return complex_number(r, i); }};class integer : public number { int val;public: integer(int v) : val(v) {} virtual double real_value() const { return this-&amp;gt;val; } virtual double imaginary_value() const { return 0; }};class real : public number { double val;public: real(double v) : val(v) {} virtual double real_value() const { return this-&amp;gt;val; } virtual double imaginary_value() const { return 0; }};class complex_number : public real { double imag;public: complex_number(double r, double i) : real(r), imag(i) {} virtual double imaginary_value() const { return 0; }};LIBRARY CLASS with ptr vectorlibrary.h#ifndef LIBRARY_H#define LIBRARY_H#include &amp;lt;vector&amp;gt;class library_item;class library { std::vector&amp;lt;library_item*&amp;gt; catalogue; // library_item is not defined! prototypepublic: library() : catalogue(std::vector&amp;lt;library_item*&amp;gt;()) {} void add_library_item(library_item *); int how_many_overdue(int days_after) const;};class library_item { bool is_checked_out;public: virtual int borrowing_period() const { return 7; } library_item() : is_checked_out(false) {} virtual void loan() { this-&amp;gt;is_checked_out = true; } virtual void give_back() { this-&amp;gt;is_checked_out = false; } virtual bool can_borrow() const { return !this-&amp;gt;is_checked_out; } virtual bool is_late(int days_after) const { return days_after &amp;gt; this-&amp;gt;borrowing_period(); }};class book : public library_item {public: book() : library_item() {} virtual int borrowing_period() const { return 14; }};class journal : public library_item {public: journal() : library_item() {}};#endiflibrary.cc#include &quot;library.h&quot;using namespace std;void library::add_library_item(library_item *new_item) { this-&amp;gt;catalogue.push_back(new_item);}int library::how_many_overdue(int days_after) const { int num_overdue = 0; for (const library_item *li : this-&amp;gt;catalogue) { if (li-&amp;gt;is_late(days_after)) num_overdue++; } return num_overdue;}#include &amp;lt;iostream&amp;gt;#include &quot;library.h&quot;using namespace std;int main() { library l; book b; journal j; b.loan(); j.loan(); l.add_library_item(&amp;amp;b); l.add_library_item(&amp;amp;j); cout &amp;lt;&amp;lt; l.how_many_overdue(10) &amp;lt;&amp;lt; endl; return 0;}Problem: 이와 같은 메인함수를 작성해보자#include &amp;lt;iostream&amp;gt;#include &quot;library.h&quot;using namespace std;library* make_small_library() { library* l = new library; book b; journal j; b.loan(); j.loan(); l-&amp;gt;add_library_item(&amp;amp;b); l-&amp;gt;add_library_item(&amp;amp;j); return l;}int main() { library* l = make_small_library(); // 에러가 나는 이유: 함수의 스택이 파괴되면서 안에 있는 멤버 변수들까지 파괴됨 (stack-buffer-underflow) cout &amp;lt;&amp;lt; l-&amp;gt;how_many_overdue(10) &amp;lt;&amp;lt; endl; delete l; return 0;}해결법: 1 catalogue에 포인터 넣지 말고 클래스 자체를 넣기 2 b와 j를 힙에 넣어서 (new, delete) 스택이 파괴되어도 사라지지 않도록 하기 3 shared ptr LIBRARY CLASS with shared ptrlibrary.h#ifndef LIBRARY_H#define LIBRARY_H#include &amp;lt;vector&amp;gt;#include &amp;lt;memory&amp;gt;class library_item;class library { std::vector&amp;lt;std::shared_ptr&amp;lt;library_item&amp;gt;&amp;gt; catalogue;public: library() : catalogue(std::vector&amp;lt;std::shared_ptr&amp;lt;library_item&amp;gt;&amp;gt;()) {} void add_library_item(std::shared_ptr&amp;lt;library_item&amp;gt;); int how_many_overdue(int days_after) const;};class library_item { bool is_checked_out;public: virtual int borrowing_period() const { return 7; } library_item() : is_checked_out(false) {} virtual void loan() { this-&amp;gt;is_checked_out = true; } virtual void give_back() { this-&amp;gt;is_checked_out = false; } virtual bool can_borrow() const { return !this-&amp;gt;is_checked_out; } virtual bool is_late(int days_after) const { return days_after &amp;gt; this-&amp;gt;borrowing_period(); }};class book : public library_item {public: book() : library_item() {} virtual int borrowing_period() const { return 14; }};class journal : public library_item {public: journal() : library_item() {}};#endiflibrary.cc#include &quot;library.h&quot;using namespace std;void library::add_library_item(shared_ptr&amp;lt;library_item&amp;gt; new_item) { this-&amp;gt;catalogue.push_back(new_item);}int library::how_many_overdue(int days_after) const { int num_overdue = 0; for (const shared_ptr&amp;lt;library_item&amp;gt; li : this-&amp;gt;catalogue) { if (li-&amp;gt;is_late(days_after)) num_overdue++; } return num_overdue;}main.cc#include &amp;lt;iostream&amp;gt;#include &amp;lt;memory&amp;gt;#include &quot;library.h&quot;using namespace std;library* make_small_library() { library* l = new library; shared_ptr&amp;lt;book&amp;gt; b = shared_ptr&amp;lt;book&amp;gt;(new book); shared_ptr&amp;lt;journal&amp;gt; j = shared_ptr&amp;lt;journal&amp;gt;(new journal); b-&amp;gt;loan(); j-&amp;gt;loan(); l-&amp;gt;add_library_item(b); l-&amp;gt;add_library_item(j); return l;}int main() { library* l = make_small_library(); cout &amp;lt;&amp;lt; l-&amp;gt;how_many_overdue(10) &amp;lt;&amp;lt; endl; delete l; return 0;}" }, { "title": "C EXAMPLES: STRUCT", "url": "/posts/struct/", "categories": "Programming, C/C++", "tags": "c, c++", "date": "2022-06-06 13:48:06 +0900", "snippet": "필자의 대학 코스 Advanced Programming에서 사용된 예시를 발췌, 정리했습니다. FINAL 시험에서 좋은 성과를 바라며…POINTPoint라는 구조체는 x좌표와 y좌표로 정의될 수 있습니다.#include &amp;lt;iostream&amp;gt;#include &amp;lt;cmath&amp;gt; // for sqrtstruct point{ double x; double y;};double d(point const * p1, point const * p2) // 1{ double x_diff = p1-&amp;gt;x - p2-&amp;gt;x; // 1 double y_diff = p1-&amp;gt;y - p2-&amp;gt;y; // 1 return sqrt(x_diff*x_diff + y_diff*y_diff);}int main(){ using namespace std; point p; // 2 cout &amp;lt;&amp;lt; &quot;x: &quot; &amp;lt;&amp;lt; flush; // 3 cin &amp;gt;&amp;gt; p.x; // 2 cout &amp;lt;&amp;lt; &quot;y: &quot; &amp;lt;&amp;lt; flush; // 3 cin &amp;gt;&amp;gt; p.y; // 2 point origin = {0, 0}; cout &amp;lt;&amp;lt; &quot;Distance: &quot; &amp;lt;&amp;lt; d(&amp;amp;p, &amp;amp;origin) &amp;lt;&amp;lt; endl; // 1 return 0;}몇 가지 의미있는 내용이 있습니다. 함수 인자로 구조체의 주솟값을 받았다면, 구조체의 변수에 접근하기 위해서는 p1-&amp;gt;x 형식으로, 즉 [구조체 포인터]-&amp;gt;[구조체의 변수] 형식으로 접근해야 합니다. 그저 구조체를 받았다면, 구조체의 변수에 접근하기 위해 p.x 형식으로, 즉 [구조체].[구조체의 변수] 형식으로 접근해야 합니다. 제시문을 출력하고 사용자의 입력을 기다릴 때에는 &amp;lt;&amp;lt; flush를 해주는 것이 관습입니다.하지만 위 코드는 밑에처럼 쓸 수도 있습니다.#include &amp;lt;iostream&amp;gt;#include &amp;lt;cmath&amp;gt; // for sqrtstruct point{ double x; double y;};double d(point const &amp;amp; p1, point const &amp;amp; p2) // 1{ double x_diff = p1.x - p2.x; // 1 double y_diff = p1.y - p2.y; // 1 return sqrt(x_diff*x_diff + y_diff*y_diff);}int main(){ using namespace std; point p; cout &amp;lt;&amp;lt; &quot;x: &quot; &amp;lt;&amp;lt; flush; cin &amp;gt;&amp;gt; p.x; cout &amp;lt;&amp;lt; &quot;y: &quot; &amp;lt;&amp;lt; flush; cin &amp;gt;&amp;gt; p.y; point origin = {0, 0}; cout &amp;lt;&amp;lt; &quot;Distance: &quot; &amp;lt;&amp;lt; d(p, origin) &amp;lt;&amp;lt; endl; // 1 return 0;}이번에는 함수의 인자를 구조체 자체로 주고 있습니다. 이 상황만 보면 누군가가 이렇게 비판하겠죠. “구조체를 인자로 전달하는 것은 구조체 전체를 복사하여 다시 연산하기 때문에 비효율적이야!” 하지만 위로 올라가서 함수의 인자 포맷을 보게 된다면, &amp;amp;가 붙어 있는 것을 알 수 있습니다. 이는 *reference**를 활용한 값의 참조이며, 이 함수는 레퍼런스로 받은 인자들에 붙은 .은 모두 -&amp;gt;로 바꾸어서 처리하게 됩니다. 즉 1에서 바로 인자들에게 접근할 수 있는 것이지요. 잘 알아두시길 바랍니다.후자의 방법이 메모리의 관점에서는 더 효율적입니다.Pointer vs Reference레퍼런스는 포인터와 중요한 차이점을 가집니다. 꼭 초기화를 시켜주지 않아도 되는 포인터와 달리, 레퍼런스는 반드시 처음에 누구의 별명이 될 것인지 지정해야 합니다. 가리키는 값이 바뀔 수 있는 포인터와 달리, 레퍼런스가 한 번 별명이 되면 절대로 다른 이의 별명이 될 수 없다. 항상 메모리상 공간을 차지하는 포인터와 달리, 레퍼런스는 메모리 상에 존재하지 않을 수도 있다.조금 사소한 것들로는… 배열과 사용할 수 없다. 포인터 연산을 할 수 없다. null-reference는 불가능, null-pointer는 가능 reference는 항상 무언가를 함의하도록 초기화되고, 그 값이 바뀌지 않는다.여기 예시가 있습니다.#include &amp;lt;iostream&amp;gt;int main(){ using namespace std; int x[] = {3, 4, 5}; int &amp;amp;a = x[1]; a++; cout &amp;lt;&amp;lt; x[1] &amp;lt;&amp;lt; endl; int &amp;amp;b = a; cout &amp;lt;&amp;lt; b &amp;lt;&amp;lt; endl; return 0;}출력 결과55왜 이런 결과가 나왔을까요? int &amp;amp;a = x[1]; 이 줄에서, a는 x[1]의 별명이 되었습니다. 즉 밑에 있는 a++은 x[1]++과 동치인 것이죠. 따라서 5가 출력됩니다.또한, int &amp;amp;b = a;에서 b는 a의 별명이 되었으므로 b 역시 x[1]의 별명이 됩니다. 따라서 5가 출력됩니다.ENUMENUM은 기존 정수형 변수를 조건을 벗어난 값으로 지정되지 않게 하고, 가독성을 높히기 위해 사용됩니다.#include &amp;lt;iostream&amp;gt;using namespace std;enum day_of_week { SUN, MON, TUE, WED, THU, FRI, SAT };string day_of_week_name(day_of_week d){ switch (d) { case SUN: return &quot;SUN&quot;; case MON: return &quot;MON&quot;; case TUE: return &quot;TUE&quot;; case WED: return &quot;WED&quot;; case THU: return &quot;THU&quot;; case FRI: return &quot;FRI&quot;; case SAT: return &quot;SAT&quot;; }}즉, enum은 switch문과 각별한 사이이다.enum은 내재적으로 int형 변수로 타입이 전환되곤 한다. 또한 global range에서 정의되기 때문에, 우리는 다른 SUN이란 변수를 만들 수 없다. 이를 막기 위해서, 혼동을 줄이기 위해서 enum class로 정의할 수 있다.#include &amp;lt;iostream&amp;gt;using namespace std;enum class day_of_week { SUN, MON, TUE, WED, THU, FRI, SAT };string day_of_week_name(day_of_week d){ switch (d) { case day_of_week::SUN: return &quot;SUN&quot;; case day_of_week::MON: return &quot;MON&quot;; case day_of_week::TUE: return &quot;TUE&quot;; case day_of_week::WED: return &quot;WED&quot;; case day_of_week::THU: return &quot;THU&quot;; case day_of_week::FRI: return &quot;FRI&quot;; case day_of_week::SAT: return &quot;SAT&quot;; }}이제 헷갈리지 않는다!ENUM으로 날짜 계산해주는 프로그램 만들기#include &amp;lt;iostream&amp;gt;enum class month {jan, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec};int days_of_month(month m){ case month::jan: case month::mar: case month::may: case month::jul: case month::aug: case month::oct: case month::dec: return 31; case month::apr: case month::jun: case month::sep: case month::nov: return 30; case month::feb: return 28}struct day_of_month{ month m; int day;}int days_between (day_of_month const &amp;amp; d1, day_of_month const &amp;amp;d2){ int total_days; for (month i = d1.m; i &amp;lt; d2.m; i = (month)((int)i + 1)) total_days += days_of_month(i); return total_days + d2.day - d1.day;}int main(){ using namespace std; day_of_month a = {month::april, 30}, {month::may, 3}; cout &amp;lt;&amp;lt; days_between(a, b) &amp;lt;&amp;lt; endl;}" }, { "title": "DANIEL&#39;s Histroty of Orthodontic Correction", "url": "/posts/tooth-transformation/", "categories": "", "tags": "decs", "date": "2022-05-18 14:02:30 +0900", "snippet": "What is Orthodontic Correction?Simply put, it means wearing braces on crooked teeth, for straightening (teeth transformation).I started to wear braces from Feb 8, 2022. So I’m in 3 month with braces.Today, I’m gonna introduce my history of teeth transformation.History of Orthdontic CorrectionThe beginningProgress of tooth transformationInsightIt is too hurt… I can’t chew well… TT The End!" }, { "title": "문제로 풀어보는 알고리즘 01장: 재귀적 프로그래밍", "url": "/posts/algorithm-with-ps-01/", "categories": "Problem Solving, 문제로 풀어보는 알고리즘", "tags": "ps, book", "date": "2022-04-19 22:40:43 +0900", "snippet": "n! 계산하기반복문을 이용하여 n! 계산하기n!은 다음과 같이 정의된다.\\[n! = 1 \\times 2 \\times \\cdots \\times n\\]int factorial(int n){ int r = 1; for(int i = 1; i &amp;lt;= n; i++) r *= i; return r;}일정한 규칙을 가진 곱셈을 반복하므로, 반복문을 사용하면 쉽게 작성할 수 있다.재귀함수를 이용하여 n! 계산하기재귀함수를 이용하여 n!을 구하기 위해서는, 재귀적으로 n!을 정의해야 한다. 재귀적으로 함수를 정의한다는 뜻, 함수 내부에서 동일한 함수를 호출한다는 것을 의미한다. 즉 수학적 관점에서는 점화식과 유사한 개념이라고 볼 수 있다. 재귀함수를 정의하기 위해서는, 두 가지를 찾아야한다. 첫번째는 Base Case이고, 두번째는 Recursive Case이다. Base Case: 동일한 함수가 계속해서 호출되다 보면, 함수를 끝낼 (즉 함수를 호출하지 않고 정적인 값만을 반환할) 조건이 필요함이 자명해보인다. 따라서 우리는 Base Case가 필요하다. 이 녀석은 호출되었을 때 값을 반환하기 위해 새로운 함수를 호출하던 함수의 궤도를 끝내는 역할을 해줄 것이다. Recursive Case: 이 경우가 바로 점화식과 같이 필요한 함수값을 동일한 함수값을 이용하여 표현하는 것이다. 대부분 f(n)을 f(n - 1)을 이용해서 표현하거나, f(n // 2)를 이용해서 표현한다. (전자를 많이 사용하지만, 뒤에서 후자에 대한 예시도 함께 다룰 것이다.) 재귀함수의 근간: 재귀함수는 재귀, 즉 동일한 함수의 호출을 반복함에 따라 Base Case에 점점 수렴해가야만 한다. (상식적으로, 그렇지 않다면 재귀함수가 어떻게 종료되겠는가? 스택 오버플로우를 야기할 것이다.) 이름 붙이기에 따라 다르겠지만, 재귀함수는 크게 두 가지로 나뉜다. 바로 값을 반환하기 위한 재귀와 특정 행동을 위한 재귀로 말이다. 값을 반환하기 위한 재귀: Recursive Case에서 return에 재귀함수가 호출된다. Base Case는 특정 값을 return한다. 특정 행동을 위한 재귀: Recursive Case에서 return을 하지 않으며, 그저 일반 라인에서 재귀함수를 호출한다. Base Case는 프로그램의 종료만을 위한 것으로, return ;과 같이 간단하게 적는다. 밑에 다양한 예시가 있다. 이러한 범주에서 구분하며 서술할 테이니, 잘 이해해놓자! n!은 다음과 같이 정의된다.\\[1! = 1 \\\\ n! = n \\times (n-1)! \\:\\:\\:\\:\\:\\: : n &amp;gt; 1\\]따라서 코드를 이렇게 쓸 수 있다.int factorial2(int n){ if (n == 1) return 1; else return n * factorial2(n - 1);}이는 값을 반환하기 위한 재귀에 해당한다.위 함수의 Base Case는 n에 1이 들어왔을 때이다. 1이 아닌 n이 들어왔을 때, Recursive Case를 타고 factorial2(n - 1) 함수를 호출할 것이고, n - 1이 1이 아니라면 또 Recursive Case를 타고 factorial2(n - 2) 값을 만들 것이다. 그렇게 파라메터의 값이 쭉 줄어들다가 만약 factorial2(1) 함수가 호출되면 1을 반환하고, 이전 놈한테 1 값을 넘겨 새로운 값을 계산하고, 그 새로운 값을 다시 이전 놈에게 넘겨 새로운 값을 계산하고… 이런 식으로 factorial2(n)의 값을 계산해 낼 수 있다.만약 Base Case가 없다면??Segmentation fault가 발생한다. 이것은 스택 오버플로우가 발생했을 때 나타나는 오류로, 수많은 재귀함수 호출로 인하여 프로그램을 강제로 종료시킨 것이다. 우리는 Base Case를 잘 작성해야만 하는 이유를 알았다!연결 리스트 출력하기지난 챕터에서 배웠던 연결리스트를 기억하는가? 연결리스트의 원소들을 출력하는 함수를 작성해보자. 지난 챕터 복습: 연결 리스트에 대하여 struct node_t: int key와 node_t* next값이 정의된 구조체를 node_t로서 정의했다. int key: 노드에 담겨있는 int값을 key라는 변수에 저장했다. node_t* next: 다음 노드를 가리키고 있는 node_t형 포인터를 next로써 정의했다. node_t* head: 처음 원소를 가리키는 node_t형 포인터를 head로써 정의했다. node_t* tail: 마지막 원소를 가리키는 node_t형 포인터를 head로써 정의했다. node_t* from을 인자로 받고, from이 가리키는 노드부터 마지막 노드까지 노드의 값들을 출력하는 함수를 작성해보자.반복문을 이용하여 연결 리스트 출력하기void print_list(node_t* from){ node_t* node; node = from; while (node != NULL) { cout &amp;lt;&amp;lt; node-&amp;gt;key &amp;lt;&amp;lt; endl; node = node-&amp;gt;next; }}노드가 NULL값을 가질 때까지, 즉 node가 끝까지 순회할 때까지 node-&amp;gt;key를 출력하고, node의 값을 node-&amp;gt;next로 업데이트하는 과정을 반복한다.재귀함수를 이용하여 연결 리스트 출력하기재귀함수를 이용하여 연결 리스트를 출력하기 위해서는, 재귀적으로 연결 리스트 출력하기 함수를 정의해야 한다.연결 리스트 출력하기 함수는 다음과 같이 정의된다. exit() : from == NULLprint(key), print_list(next) : from != NULL이렇게 함수를 정의하고 나면, Recursive Case를 반복하여 호출함에 따라 Base Case에 수렴함을 확인할 수 있다. 노드의 다음, 다음, 다음, 다음, … 이 호출되며 연결 리스트의 마지막을 향해 달리는데 (Recursive Case), 연결 리스트의 마지막 값은 NULL이기 때문이다. (Base Case)from값이 NULL이면 함수 호출을 종료하고, 아니라면 key값을 출력한 다음 이 함수를 호출하되 인자를 다음 노드의 포인터 next로 넣는 것이다. 이로써 연결 리스트를 타고 계속 노드의 key 값을 출력하고, 노드가 끝에 다다르면 함수 호출을 종료할 수 있다.void print_list2(node_t* from){ node_t* node; if (from == NULL) return; printf(&quot;%d &quot;, from-&amp;gt;key); print_list2(from-&amp;gt;next);}이는 특정 행동을 위한 재귀에 해당한다.재귀함수를 이용하여 연결 리스트 역순으로 출력하기연결 리스트를 역순으로 출력하기 위해서는 어떻게 해야할까? 이를 반복문으로 구현하고자 한다면, 꽤 복잡할 것이다. 하지만 재귀함수를 이용하면 쉽게 해결할 수 있다. 특정 행동을 위한 재귀에서는 행동과 호출의 순서가 중요하다! 위 예시에서 연결 리스트의 값을 순서대로 출력하기 위해서, 우리는 행동을 한 후에 다음 함수를 호출하는 방식으로 코드를 짰다. 하지만 호출을 한 후에 행동을 하는 식으로 순서를 바꾸면 어떤 결과가 나올까? 우선 스택에 대한 개념이 필요한데, 우리가 A 스택에서 특정 함수를 호출하게 되면 A에서 진행되던 모든 작업이 멈추고 (정확히는 코드의 독해가 함수를 호출한 행에서 멈추고), B라는 새로운 스택에서 작업을 진행하게 된다. 그리고 B 스택에서 함수 값이 반환되면 B 스택을 빠져나온 후 다시 A 스택으로 회귀하여 작업을 재개한다. 이러한 관점에서 보았을 때, 호출 후 행동은 약간 기이하다. 호출 바로 행동을 하지 않기 때문이다. 하지만 호출 후 함수값이 바로 반환되었다면, 곧바로 행동을 한다고 전제할 수 있을 것이다. 이제 느낌이 오는가? 호출-행동 쌍을 넘버링한 후 실행되는 순서를 적어보겠다. 호출₁→호출₂→호출₃→…→호출ⁿ→행동ⁿ→…→호출₃→호출₂→호출₁ (n번째 호출이 Base Case라 전제) 느낌이 오는가? 그렇다면 우리는 역순으로 행동이 일어날 것이라 예상할 수 있다. 우리는 위에서 재귀함수를 작성할 때 호출 후 행동으로 작성하면 행동이 역순으로 수행된다는 것을 알았다.void print_list2(node_t* from){ node_t* node; if (from == NULL) return; print_list2(from-&amp;gt;next); printf(&quot;%d &quot;, from-&amp;gt;key);}즉 순서만 바꿔준다면 연결 리스트의 값이 역순으로 출력될 것임을 기대할 수 있다.몇 개의 원소를 넣어야 스택 오버 플로우가 발생할까? (작성 중)디스크 드라이브의 모든 파일명을 출력하는 프로그램이항계수이항계수\\(_{n}\\textrm{C}_{r}\\)은 서로 다른 n개의 원소 중 r개의 원소를 순서를 고려하지 않고 뽑는 경우의 수를 말한다.이는 공식\\(_{n}\\textrm{C}_{r} = \\frac{n \\times (n-1) \\times (n-2) \\times \\cdots \\times (n-r+1)}{r \\times (r-1) \\times (r-2) \\times \\cdots \\times 1}\\)로 계산될 수 있다.하지만 이를 재귀적으로 풀면 더 쉽게 쓸 수 있지 않을까?재귀적으로 이항계수 계산하기재귀함수를 이용하여 이항계수를 계산하기 위해서는, 재귀적으로 이항계수를 정의해야 한다.이항계수는 다음과 같이 정의된다. Base Case\\(_{n}\\textrm{C}_{0} = _{n}\\textrm{C}_{n} = 1\\)Recursive Case (r &amp;gt; 0)\\(_{n}\\textrm{C}_{r} = _{n-1}\\textrm{C}_{r-1} + _{n-1}\\textrm{C}_{r}\\)이는 Recursive Case를 호출할 때마다 n과 r의 값이 점점 줄어들어 Base Case에 수렴함을 확인할 수 있다.long long choose(int n, int r){ if (r == 0 || n == r) return 1; return choose(n - 1, r - 1) choose(n - 1, r);}이는 값을 반환하기 위한 재귀에 해당한다. 이항계수의 값은 기하급수적으로 커지기 때문에 반환 타입을 long long으로 설정하였다.메모이제이션을 이용하여 이항계수 계산하기 (작성 중)피보나치 수열피보나치 수열은 대표적인 점화식 수열이다. 피보나치 수열은 수열의 값이 이전 두 수의 합으로 정의되는 수열이다.\\(1, 1, 2, 3, 5, 8, 13, \\cdots\\)과 같이 정의된다.재귀함수를 이용하여 피보나치 수 구하기재귀함수를 이용하여 피보나치 수를 구하기 위해서는, 재귀적으로 피보나치 수를 정의해야 한다. (사실 피보나치 수의 정의가 점화식의 형태이기에, 매우 쉽게 정의할 수 있다.)피보나치 수는 다음과 같이 정의된다. Base Case\\(f_{1} = 1, f_{2} = 1\\)Recursive Case (n &amp;gt; 3)\\(f_{n} = f_{n-1} + f_{n-2}\\)이는 Recursive Case를 호출할 때마다 n의 값이 점점 줄어들어 Base Case에 수렴함을 확인할 수 있다.long long fibo(int n){ if (r == 0 || n == r) return 1; return choose(n - 1, r - 1) choose(n - 1, r);}이는 값을 반환하기 위한 재귀에 해당한다.메모이제이션을 이용하여 피보나치 수 구하기금액을 지불하는 방법의 수 구하기1만원, 2만원, 5만원, 10만원, 20만원, 50만원 총 6가지 종류의 지폐가 있을 때, 100만원을 지불하는 방법의 수는 총 몇 가지일까?예를 들면\\(100 = 1 \\times 10 + 10 \\times 4 + 50 \\times 1\\)\\(100 = 10 \\times 2 + 20 \\times 4\\)\\(\\vdots\\)등등이 있을 수 있다.반복문으로 금액을 지불하는 방법의 수 구하기가장 NAIVE하게 생각하기 위해, 지폐의 단위가 2가지 종류가 있다고 생각해보자.그렇다면 그냥 한 지폐의 단위를 계속 금액에서 빼고, 빼진 금액이 남은 지폐의 단위를 이용하여 지불될 수 있는지 확인하면 된다. (즉 빼진 금액이 남은 지페의 단위로 나누어 떨어지는지 확인하면 된다.)int main(){ int bills[2] = {20, 50}; int count = 0; int money = 100; for (int i0 = money; i0 &amp;gt;= 0; i0 -= bills[0]) if (i0 % bills[1] == 0) count++; cout &amp;lt;&amp;lt; count &amp;lt;&amp;lt; endl; return 0;}이를 6가지 지페의 단위로 확장시키면 다음과 같다.int main(){ int bills[6] = {1, 2, 5, 10, 20, 50}; int count = 0; int money = 100; for (int i0 = money; i0 &amp;gt;= 0; i0 -= bills[0]) for (int i1 = i0; i1 &amp;gt;= 0; i1 -= bills[1]) for (int i2 = i1; i2 &amp;gt;= 0; i2 -= bills[2]) for (int i3 = i2; i3 &amp;gt;= 0; i3 -= bills[3]) for (int i4 = i3; i4 &amp;gt;= 0; i4 -= bills[4]) if (i4 % bills[5] == 0) count++; cout &amp;lt;&amp;lt; count &amp;lt;&amp;lt; endl; return 0;}이 프로그램은 올바르고, 나름 빠르지만 유연하지 못하다. 우선 지폐의 단위의 종류 수가 6가지로 고정되어 있어, 지폐가 몇 종류인지 입력받고, 단위의 종류를 차례대로 입력받아 출력하는 문제에 적용이 불가능하다. (for문의 개수를 코드에서 조정하는 것은 불가능하기 때문이다.)재귀함수로 금액을 지불하는 방법의 수 구하기재귀함수를 이용하여 금액을 지불하는 방법의 수를 구하기 위해서는, 재귀적으로 금액을 지불하는 방법의 수를 정의해야 한다.우선 금액을 지불하는 방법의 수를 반환하는 함수를 pay(m, n)으로 정의하자. pay(m, n): n종류의 지폐 bills[0], bills[1], …, bills[n - 1]을 사용하여 m원을 지불하는 방법의 수그러면 pay(m, n)는 다음과 같이 정의된다. Base Case (n = 1)\\(\\begin{cases} 1 &amp;amp; \\text{ if } \\text{m \\% bills[0] == 0} \\\\ 0 &amp;amp; \\text{ if } \\text{m \\% bills[0] != 0} \\end{cases}\\)Recursive Case (n &amp;gt;= 2)\\(\\sum_{\\text{i=0}}^{\\text{m/bills[n-1]}} \\text{pay(m-bills[n-1]} \\times \\text{i, n-1)}\\)Recursive Case를 반복할수록 n의 값이 점점 줄어들기에, Base Case에 수렴함을 확인할 수 있다.이를 코드로 작성하면 다음과 같다.int pay(int money, int* bills, int n){ int count = 0; if (n == 1) if (m % bills[0] == 0) return 1; else return 0; for (int i = 0; i &amp;lt;= (money / bills[n - 1]); i++) count += pay(money - bills[n - 1] * i, bills, n - 1); return count;}이는 값을 반환하기 위한 재귀에 해당한다.수분할n 수분할은 자연수 n을 순서에 상관 없이 하나 이상의 자연수의 합으로 나타내는 방법이다.예를 들어 3수분할 4수분할 5수분할 1+1+1 1+1+1+1 1+1+1+1+1 2+1 2+1+1 2+1+1+1 3 2+2 2+2+1   3+1 3+1+1   4 3+2     4+1     5 와 같은 형태로 나타낼 수 있다.일반적인 수분할n/m 수분할은 n을 순서에 상관 없이 하나 이상의 m 이하 자연수로만 나타내는 방법이다.예를 들어 4/1 3/2 5/2 5/3 1+1+1+1 1+1+1 1+1+1+1+1 1+1+1+1+1   2+1 2+1+1+1 2+1+1+1     2+2+1 2+2+1       3+1+1       3+2 와 같은 형태로 나타낼 수 있다.앞서 설명했던 n 수분할은 n/n 수분할이라고 할 수 있다.n &amp;lt; m 이면 n/m 수분할은 n/n 수분할과 같다.재귀함수로 수분할의 개수 구하기재귀함수를 이용하여 수분할의 개수를 구하기 위해서는, 재귀적으로 수분할의 개수를 정의해야 한다.우선 n/m 수분할의 개수를 반환하는 함수를 partition(n, m)으로 정의하자.그러면 partition(n, m)는 다음과 같이 정의된다. Base Case (n = 0)\\(\\text{partition(0,m)} = 1\\)Recursive Case (n &amp;gt;= 1)\\(\\text{partition(n,m)} = \\sum_{\\text{i=1}}^{\\text{m}} \\text{partition(n-i,i)}\\)Recursive Case를 반복하여 호출할수록 n의 값이 점점 줄어들기에, Base Case에 수렴함을 확인할 수 있다.int partition(int n, int m){ int count = 0; if (n &amp;lt; m) m = n; if (n == 0) return 1; for (int i = 1; i &amp;lt;= m; i++) count += partition(n - i, i); return count;}이는 값을 반환하기 위한 재귀에 해당한다.메모이제이션을 이용한 재귀함수로 수분할의 개수 구하기재귀함수로 순서를 고려하는 수분할의 개수 구하기순서를 고려한 수분할은 내림차순으로 정렬했던 이제까지와 다르게, 서로 다른 순서도 고려함을 의미한다.예를 들어 3수분할 4수분할 1+1+1 1+1+1+1 1+2 1+1+2 2+1 1+2+1 3 1+3   2+1+1   2+2   3+1   4 와 같은 형태로 나타낼 수 있다.재귀함수를 이용하여 순서를 수분할의 개수를 구하기 위해서는, 재귀적으로 순서를 고려한 수분할의 개수를 정의해야 한다.우선 n/m 수분할의 개수를 반환하는 함수를 partition2(n, m)으로 정의하자.그러면 partition2(n)는 다음과 같이 정의된다. Base Case (n = 1)\\(\\text{partition2(1)} = 1\\)Recursive Case (n &amp;gt;= 2)\\(\\text{partition2(n)} = \\sum_{\\text{i=1}}^{\\text{n-1}} \\text{partition2(n-i)} + 1\\)Recursive Case를 반복하여 호출할수록 n의 값이 점점 줄어들기에, Base Case에 수렴함을 확인할 수 있다.int partition2(int n){ int count = 0; if (n == 1) return 1; for (int i = 1; i &amp;lt;= n - 1; i++) count += partition2(n - i); return count + 1;}다양한 재귀함수 예시필자의 대학 코스 Advanced Programming에서 사용된 예시를 발췌, 정리했습니다.Calculate Power Base Case (y = 0) \\[x^{0} = 1\\] Recursive Case (y &amp;gt;= 1) \\[x^{y} = x \\times x^{y-1}\\] unsigned long power(unsigned int x, unsigned int y){ if (y == 0) return 1; else return x * power(x, y - 1);}하지만 이 코드는 y만큼의 스택을 생성하기에 Stack Overflow가 발생할 가능성이 다분하다. 따라서 다음과 같이 코드를 작성하여 해결할 수도 있다. Base Case (y = 0) \\[x^{0} = 1\\] Recursive Case (y &amp;gt;= 1) \\[x^{y} = \\begin{cases} x \\times x^{y-1} &amp;amp; \\text{ if y = odd } \\\\ x^{y/2} \\times x^{y/2} &amp;amp; \\text{ if y = even } \\end{cases}\\] unsigned long power(unsigned int x, unsigned int y){ if (y == 0) return 1; else if (y % 2 == 0) unsigned long x_y2 = power(x, y / 2); return x_y2 * x_y2; else return x * power(x, y - 1);} 가능하면 Reduce by RATIO, not by CONSTANT.Calculate Nth Fibonacci Number Base Case (n = 0 or 1) \\[\\text{fib(0)} = 0\\] \\[\\text{fib(1)} = 1\\] Recursive Case (n &amp;gt;= 2) \\[\\text{fib(n)} = \\text{fib(n - 1)} + \\text{fib(n - 2)}\\] unsigned long fib(int n){ if (n &amp;lt;= 1) return n; return fib(n - 1) + fib(n - 2);}Calculate N Factorial Base Case (n = 0) \\[\\text{fac(0)} = 1\\] Recursive Case (n &amp;gt;= 1) \\[\\text{fac(n)} = \\text{n} \\times \\text{fac(n - 1)}\\] unsigned long fac(int n){ if (n == 0) return 1; return n * fac(n - 1);}Find a Square Root using a Binary Search What is Binary Search or Bisection Method? Choose an initial lower boundary and an upper boundary for the ANSWER. Progressively narrow boundaries, until they are narrow enough for our purpose. 예를 들어, 7의 제곱근을 찾는다고 해보자. 7의 제곱근은 0에서 7 사이에 있을거야. Midpoint(= 3.5)를 시도해보자.\\(3.5^{2} = 12.25\\) 12.25는 7보다 크므로 7의 제곱근은 0에서 3.5 사이에 있을거야. Midpoint(= 1.75)를 시도해보자.\\(1.75^{2} = 3.0625\\) 3.0625는 7보다 작으므로 7의 제곱근은 1.75에서 3.5 사이에 있을거야. Midpoint(= 2.625)를 시도해보자.\\(2.625^{2} = 6.890625\\) 6.890625는 7보다 작으므로 7의 제곱근은 2.625에서 3.5 사이에 있을거야. Midpoint(= 3.0625)를 시도해보자.\\(3.0625^{2} = 9.37890625\\) 9.37890625는 7보다 크므로 7의 제곱근은 2.625에서 3.0625 사이에 있을거야. Midpoint를 시도해보자. …이러한 과정이 바로 Binary Search 이다! Base Case (close enough to answer) \\[\\text{return midpoint;} \\text{ if } \\text{midpoint}^{2} = \\text{n}\\] Recursive Case (not close enough to answer) \\[\\begin{cases} \\text{return binary\\_search(n, lower, midpoint)} &amp;amp; \\text{ if } \\text{midpoint}^{2} &amp;gt; \\text{n} \\\\ \\text{return binary\\_search(n, midpoint, upper)} &amp;amp; \\text{ if } \\text{midpoint}^{2} &amp;lt; \\text{n} \\end{cases}\\] double binary_search(double n, double lower, double upper){ double mid = (lower + upper) / 2; double mid2 = mid * mid; if (fabs(mid2 - n) &amp;lt;= 0.001) // #include&amp;lt;cmath&amp;gt; return mid; else { if (mid2 &amp;gt; n) return binary_search(n, lower, mid); else return binary_search(n, mid, upper); }}double square_root(double val){ return binary_search(val, 0, val);} 위와 같은 방식으로 인자를 3개 받는 함수를 실행하기 위해서 그 함수를 실행시키는 것이 아니라, 인자를 하나 받는 함수를 구현한 후 인자를 3개 받는 함수를 호출할 수도 있다.Is Palindrome?Palindrome이란 앞으로, 뒤로 읽어도 동일한 문자열을 말한다. 예를 들어 ‘radar’, ‘noon’ 등이 이에 속한다. c_str() method C 스타일의 string을 C++에서 사용할 수 있도록 해준다. 이들은 문자열의 첫번째 글자를 가리키는 포인터 ptr과 문자열의 길이 len으로 구성된다. Base Case (len &amp;lt;= 1) \\[\\text{ return True } \\text{ if } \\text{ len } &amp;lt;= 1\\] Recursive Case (len &amp;gt;= 2) (양끝이 동일 and 내부 문자열이 palindrome) \\[\\text{return (ptr[0] == ptr[len -1]) and is\\_palindrome(ptr + 1, len - 2)}\\] bool is_palindrome(char const* ptr, size_t len){ if (len &amp;lt;= 1) return true; return (ptr[0] == ptr[len - 1] &amp;amp;&amp;amp; is_palindrome(ptr + 1, len - 2));}int main(){ string x; getline(cin, x); cout &amp;lt;&amp;lt; is_palindrome(x.c_str(), x.length()) &amp;lt;&amp;lt; endl; return 0;} getline(), c_str(), length() 메소드의 사용법을 잘 숙지해놓자. gdb [executable]을 console에 입력함으로써 재귀함수의 스택을 추적할 수 있다.Print Tower of Hanoi SolutionTower of Hanoi은 한 봉에 있는 서로 다른 크기의 Disk들을 다른 봉으로 옮기는 문제이다.Rules 한 번에 하나의 Disk를 이동 가능 쌓여있는 Disk들 중 가장 위의 Disk만 이동 가능 Disk는 자신보다 크기가 큰 Disk 위에만 놓일 수 있음 Base Case (1 Disk) \\[\\text{print(from → to) } \\text{ if } \\text{1 Disk}\\] Recursive Case \\[\\text{1. move(n - 1 disks from → other)}, \\\\ \\text{2. move(1 disk from → to)}, \\\\ \\text{3. move(n - 1 disks other → to)}\\] void move_discs(int num_discs, int from, int to){ if (num_discs == 1) cout &amp;lt;&amp;lt; &quot;from &quot; &amp;lt;&amp;lt; from &amp;lt;&amp;lt; &quot; to &quot; &amp;lt;&amp;lt; to &amp;lt;&amp;lt; endl; else { // 0. other rod 찾기 int other; for (other = 1; other == from || other == to; other++) ; // 1. move (n - 1 disks from → other) move_discs(num_discs - 1, from, other); // 2. move (1 disk from → to) cout &amp;lt;&amp;lt; &quot;from &quot; &amp;lt;&amp;lt; from &amp;lt;&amp;lt; &quot; to &quot; &amp;lt;&amp;lt; to &amp;lt;&amp;lt; endl; // 3. move (n - 1 disks other → to) move_discs(num_discs - 1, other, to); }}ㄷㄷ 너무 소름돋는다…! 잘 보이지 않더라도 무지성으로 적으면 해결이 되다니!Solving Simple Sudoku Backtracking에 대하여…Backtracking (choose-explore-unchoose) : 어떤 경우가 나올지 모르는 경우를 선택 - 직접 해보며 되는지 안되는지 관찰 - 안되면 Undo하는 과정을 말한다.3X3 스도쿠가 있을 때, 빈 칸에 특정 숫자(1~3)을 넣어보고 오류가 있으면 (illegal state) 빡구 (backtrack) 오류가 없으면 Winnning State, 종료// BLANK는 -1로 채움#define BLANK -1// 각 행들에 중복되는 원소가 없는지 체크bool has_invalid_row(int const** board){ for (int row = 0; row &amp;lt; 3; row++) { // 등장한 원소는 true로 바꿀 거임 bool seen[3] = { false, false, false }; for (int col = 0; col &amp;lt; 3; col++) { if (board[row][col] != BLANK) // 채워져있는 칸에 대하여 if (seen[board[row][col]]) // 만약 본 게 또 채워져 있으면 return true; // invalid else seen[board[row][col]] = true; // 못 본 놈이면 봤다고 체크하기 } } return false; // 모든 원소에 대하여 문제 없으면 valid}// 각 열들에 중복되는 원소가 없는지 체크bool has_invalid_column(int const** board){ for (int col = 0; col &amp;lt; 3; col++) { // 등장한 원소는 true로 바꿀 거임 bool seen[3] = { false, false, false }; for (int row = 0; row &amp;lt; 3; row++) { if (board[row][col] != BLANK) // 채워져있는 칸에 대하여 if (seen[board[row][col]]) // 만약 본 게 또 채워져 있으면 return true; // invalid else seen[board[row][col]] = true; // 못 본 놈이면 봤다고 체크하기 } } return false; // 모든 원소에 대하여 문제 없으면 valid}bool is_invalid(int const** board){ return has_invalid_row(board) || has_invalid_column(board);}bool rows_win(int const** board){ for (int row = 0; row &amp;lt; 3; row++) { bool seen[3] = { false, false, false }; for (int col = 0; col &amp;lt; 3; col++) if (board[row][col] != BLANK) seen[board[row][col]] = true; // 모든 원소에 대하여 본 놈들은 true로 바꾸기 for (int i = 0; i &amp;lt; 3; i++) if (!seen[i]) // 만약 못 본 원소가 있다면 invalid return false; } return true; // 못 본 원소없이 모두 봤으면 win!}bool columns_win(int const** board){ for (int col = 0; col &amp;lt; 3; col++) { bool seen[3] = { false, false, false }; for (int row = 0; row &amp;lt; 3; row++) if (board[row][col] != BLANK) seen[board[row][col]] = true; // 모든 원소에 대하여 본 놈들은 true로 바꾸기 for (int i = 0; i &amp;lt; 3; i++) if (!seen[i]) // 만약 못 본 원소가 있다면 invalid return false; } return true; // 못 본 원소없이 모두 봤으면 win!}bool wins(int const** board){ return rows_win(board) &amp;amp;&amp;amp; columns_win(board);}bool solve_puzzle(int** board){ if (is_invalid((int const**)board)) return false; if (wins((int const**)board)) return true; for (int row = 0; row &amp;lt; 3; row++) for (int col = 0; col &amp;lt; 3; col++) if (board[row][col] == BLANK) // 모든 빈칸들에 대하여 { for (int guess = 0; guess &amp;lt; 3; guess++) { board[row][col] = guess; if (solve_puzzle(board)) return true; // valid면 유지 } board[row][col] = BLANK; return false; // invalid면 backtrack, false 반환 } return false;}int main(){ int row1[] = {1, 2, 0}; int row2[] = { BLANK, BLANK, BLANK }; int row3[] = { BLANK, BLANK, BLANK }; int* rows[] = { row1, row2, row3 }; if (solve_puzzle(rows)) for (int r = 0; r &amp;lt; 3; r++) for (int c = 0; c &amp;lt; 3; c++) cout &amp;lt;&amp;lt; rows[r][c] &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; endl;}" }, { "title": "C EXAMPLES: RECURSION", "url": "/posts/recursion/", "categories": "Programming, C/C++", "tags": "c, c++", "date": "2022-04-19 21:31:06 +0900", "snippet": "필자의 대학 코스 Advanced Programming에서 사용된 예시를 발췌, 정리했습니다.Calculate Power Base Case (y = 0) \\[x^{0} = 1\\] Recursive Case (y &amp;gt;= 1) \\[x^{y} = x \\times x^{y-1}\\] unsigned long power(unsigned int x, unsigned int y){ if (y == 0) return 1; else return x * power(x, y - 1);}하지만 이 코드는 y만큼의 스택을 생성하기에 Stack Overflow가 발생할 가능성이 다분하다. 따라서 다음과 같이 코드를 작성하여 해결할 수도 있다. Base Case (y = 0) \\[x^{0} = 1\\] Recursive Case (y &amp;gt;= 1) \\[x^{y} = \\begin{cases} x \\times x^{y-1} &amp;amp; \\text{ if y = odd } \\\\ x^{y/2} \\times x^{y/2} &amp;amp; \\text{ if y = even } \\end{cases}\\] unsigned long power(unsigned int x, unsigned int y){ if (y == 0) return 1; else if (y % 2 == 0) unsigned long x_y2 = power(x, y / 2); return x_y2 * x_y2; else return x * power(x, y - 1);} 가능하면 Reduce by RATIO, not by CONSTANT.Calculate Nth Fibonacci Number Base Case (n = 0 or 1) \\[\\text{fib(0)} = 0\\] \\[\\text{fib(1)} = 1\\] Recursive Case (n &amp;gt;= 2) \\[\\text{fib(n)} = \\text{fib(n - 1)} + \\text{fib(n - 2)}\\] unsigned long fib(int n){ if (n &amp;lt;= 1) return n; return fib(n - 1) + fib(n - 2);}Calculate N Factorial Base Case (n = 0) \\[\\text{fac(0)} = 1\\] Recursive Case (n &amp;gt;= 1) \\[\\text{fac(n)} = \\text{n} \\times \\text{fac(n - 1)}\\] unsigned long fac(int n){ if (n == 0) return 1; return n * fac(n - 1);}Find a Square Root using a Binary Search What is Binary Search or Bisection Method? Choose an initial lower boundary and an upper boundary for the ANSWER. Progressively narrow boundaries, until they are narrow enough for our purpose. 예를 들어, 7의 제곱근을 찾는다고 해보자. 7의 제곱근은 0에서 7 사이에 있을거야. Midpoint(= 3.5)를 시도해보자. \\(3.5^{2} = 12.25\\) 12.25는 7보다 크므로 7의 제곱근은 0에서 3.5 사이에 있을거야. Midpoint(= 1.75)를 시도해보자. \\(1.75^{2} = 3.0625\\) 3.0625는 7보다 작으므로 7의 제곱근은 1.75에서 3.5 사이에 있을거야. Midpoint(= 2.625)를 시도해보자. \\(2.625^{2} = 6.890625\\) 6.890625는 7보다 작으므로 7의 제곱근은 2.625에서 3.5 사이에 있을거야. Midpoint(= 3.0625)를 시도해보자. \\(3.0625^{2} = 9.37890625\\) 9.37890625는 7보다 크므로 7의 제곱근은 2.625에서 3.0625 사이에 있을거야. Midpoint를 시도해보자. …이러한 과정이 바로 Binary Search 이다! Base Case (close enough to answer) \\[\\text{return midpoint;} \\text{ if } \\text{midpoint}^{2} = \\text{n}\\] Recursive Case (not close enough to answer) \\[\\begin{cases} \\text{return binary_search(n, lower, midpoint)} &amp;amp; \\text{ if } \\text{midpoint}^{2} &amp;gt; \\text{n} \\\\ \\text{return binary_search(n, midpoint, upper)} &amp;amp; \\text{ if } \\text{midpoint}^{2} &amp;lt; \\text{n} \\end{cases}\\] double binary_search(double n, double lower, double upper){ double mid = (lower + upper) / 2; double mid2 = mid * mid; if (fabs(mid2 - n) &amp;lt;= 0.001) // #include&amp;lt;cmath&amp;gt; return mid; else { if (mid2 &amp;gt; n) return binary_search(n, lower, mid); else return binary_search(n, mid, upper); }}double square_root(double val){ return binary_search(val, 0, val);} 위와 같은 방식으로 인자를 3개 받는 함수를 실행하기 위해서 그 함수를 실행시키는 것이 아니라, 인자를 하나 받는 함수를 구현한 후 인자를 3개 받는 함수를 호출할 수도 있다.Is Palindrome?Palindrome이란 앞으로, 뒤로 읽어도 동일한 문자열을 말한다. 예를 들어 ‘radar’, ‘noon’ 등이 이에 속한다. c_str() method C 스타일의 string을 C++에서 사용할 수 있도록 해준다. 이들은 문자열의 첫번째 글자를 가리키는 포인터 ptr과 문자열의 길이 len으로 구성된다. Base Case (len &amp;lt;= 1) \\[\\text{ return True } \\text{ if } \\text{ len } &amp;lt;= 1\\] Recursive Case (len &amp;gt;= 2) (양끝이 동일 and 내부 문자열이 palindrome) \\[\\text{return (ptr[0] == ptr[len -1]) and is_palindrome(ptr + 1, len - 2)}\\] bool is_palindrome(char const* ptr, size_t len){ if (len &amp;lt;= 1) return true; return (ptr[0] == ptr[len - 1] &amp;amp;&amp;amp; is_palindrome(ptr + 1, len - 2));}int main(){ string x; getline(cin, x); cout &amp;lt;&amp;lt; is_palindrome(x.c_str(), x.length()) &amp;lt;&amp;lt; endl; return 0;} getline(), c_str(), length() 메소드의 사용법을 잘 숙지해놓자. gdb [executable]을 console에 입력함으로써 재귀함수의 스택을 추적할 수 있다.Print Tower of Hanoi SolutionTower of Hanoi은 한 봉에 있는 서로 다른 크기의 Disk들을 다른 봉으로 옮기는 문제이다.Rules 한 번에 하나의 Disk를 이동 가능 쌓여있는 Disk들 중 가장 위의 Disk만 이동 가능 Disk는 자신보다 크기가 큰 Disk 위에만 놓일 수 있음 Base Case (1 Disk) \\[\\text{print(from → to) } \\text{ if } \\text{1 Disk}\\] Recursive Case \\(\\text{1. move(n - 1 disks from → other)}\\) \\ \\(\\text{2. move(1 disk from → to)}\\) \\ \\(\\text{3. move(n - 1 disks other → to)}\\) \\ void move_discs(int num_discs, int from, int to){ if (num_discs == 1) cout &amp;lt;&amp;lt; &quot;from &quot; &amp;lt;&amp;lt; from &amp;lt;&amp;lt; &quot; to &quot; &amp;lt;&amp;lt; to &amp;lt;&amp;lt; endl; else { // 0. other rod 찾기 int other; for (other = 1; other == from || other == to; other++) ; // 1. move (n - 1 disks from → other) move_discs(num_discs - 1, from, other); // 2. move (1 disk from → to) cout &amp;lt;&amp;lt; &quot;from &quot; &amp;lt;&amp;lt; from &amp;lt;&amp;lt; &quot; to &quot; &amp;lt;&amp;lt; to &amp;lt;&amp;lt; endl; // 3. move (n - 1 disks other → to) move_discs(num_discs - 1, other, to); }}ㄷㄷ 너무 소름돋는다…! 잘 보이지 않더라도 무지성으로 적으면 해결이 되다니!Solving Simple Sudoku Backtracking에 대하여…Backtracking (choose-explore-unchoose) : 어떤 경우가 나올지 모르는 경우를 선택 - 직접 해보며 되는지 안되는지 관찰 - 안되면 Undo하는 과정을 말한다.3X3 스도쿠가 있을 때, 빈 칸에 특정 숫자(1~3)을 넣어보고 오류가 있으면 (illegal state) 빡구 (backtrack) 오류가 없으면 Winnning State, 종료// BLANK는 -1로 채움#define BLANK -1// 각 행들에 중복되는 원소가 없는지 체크bool has_invalid_row(int const** board){ for (int row = 0; row &amp;lt; 3; row++) { // 등장한 원소는 true로 바꿀 거임 bool seen[3] = { false, false, false }; for (int col = 0; col &amp;lt; 3; col++) { if (board[row][col] != BLANK) // 채워져있는 칸에 대하여 if (seen[board[row][col]]) // 만약 본 게 또 채워져 있으면 return true; // invalid else seen[board[row][col]] = true; // 못 본 놈이면 봤다고 체크하기 } } return false; // 모든 원소에 대하여 문제 없으면 valid}// 각 열들에 중복되는 원소가 없는지 체크bool has_invalid_column(int const** board){ for (int col = 0; col &amp;lt; 3; col++) { // 등장한 원소는 true로 바꿀 거임 bool seen[3] = { false, false, false }; for (int row = 0; row &amp;lt; 3; row++) { if (board[row][col] != BLANK) // 채워져있는 칸에 대하여 if (seen[board[row][col]]) // 만약 본 게 또 채워져 있으면 return true; // invalid else seen[board[row][col]] = true; // 못 본 놈이면 봤다고 체크하기 } } return false; // 모든 원소에 대하여 문제 없으면 valid}bool is_invalid(int const** board){ return has_invalid_row(board) || has_invalid_column(board);}bool rows_win(int const** board){ for (int row = 0; row &amp;lt; 3; row++) { bool seen[3] = { false, false, false }; for (int col = 0; col &amp;lt; 3; col++) if (board[row][col] != BLANK) seen[board[row][col]] = true; // 모든 원소에 대하여 본 놈들은 true로 바꾸기 for (int i = 0; i &amp;lt; 3; i++) if (!seen[i]) // 만약 못 본 원소가 있다면 invalid return false; } return true; // 못 본 원소없이 모두 봤으면 win!}bool columns_win(int const** board){ for (int col = 0; col &amp;lt; 3; col++) { bool seen[3] = { false, false, false }; for (int row = 0; row &amp;lt; 3; row++) if (board[row][col] != BLANK) seen[board[row][col]] = true; // 모든 원소에 대하여 본 놈들은 true로 바꾸기 for (int i = 0; i &amp;lt; 3; i++) if (!seen[i]) // 만약 못 본 원소가 있다면 invalid return false; } return true; // 못 본 원소없이 모두 봤으면 win!}bool wins(int const** board){ return rows_win(board) &amp;amp;&amp;amp; columns_win(board);}bool solve_puzzle(int** board){ if (is_invalid((int const**)board)) return false; if (wins((int const**)board)) return true; for (int row = 0; row &amp;lt; 3; row++) for (int col = 0; col &amp;lt; 3; col++) if (board[row][col] == BLANK) // 모든 빈칸들에 대하여 { for (int guess = 0; guess &amp;lt; 3; guess++) { board[row][col] = guess; if (solve_puzzle(board)) return true; // valid면 유지 } board[row][col] = BLANK; return false; // invalid면 backtrack, false 반환 } return false;}int main(){ int row1[] = {1, 2, 0}; int row2[] = { BLANK, BLANK, BLANK }; int row3[] = { BLANK, BLANK, BLANK }; int* rows[] = { row1, row2, row3 }; if (solve_puzzle(rows)) for (int r = 0; r &amp;lt; 3; r++) for (int c = 0; c &amp;lt; 3; c++) cout &amp;lt;&amp;lt; rows[r][c] &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; endl;}" }, { "title": "DANIEL&#39;s MIDTERM SCHEDULE &amp; STRATEGY", "url": "/posts/midterm-schedule/", "categories": "", "tags": "decs", "date": "2022-04-15 14:49:30 +0900", "snippet": "Schedule of MIDTERM 0416 10:30 Calculus II 0421 13:00 Global Engineering and English Comminication 0421 14:30 Advanced Programming 0422 10:30 Chinise 0427 Assignment 3 from Data Mining 0429 Assignment 2 from System Programming On 0421, There is 2 Exams on a day. I have to consider it.Strategy of MIDTERMCalculus II Solving all of Discussion Problems. Solving all of Quiz and ICP. Memorize some major formulas.Global Engineering and English Communication Read all of PPT. Read the textbook carefully. Summarize major concepts by hand writing.Advanced Programming Understand all of example from recorded lecture. Review Quiz. (about pointer) Review Assignments. (about array, recursion, std)Chinise Memorize all chinise Characters. Chinise test is held in 경영관 111, Offline Test.After MIDTERM…There are 2 assignments deadline right after MIDTERM. I have to look carefully on It. The End!" }, { "title": "C LANGUAGE QUIZ 00: Pointer", "url": "/posts/c-quiz/", "categories": "Programming, C/C++", "tags": "c, c++, qz", "date": "2022-04-05 22:24:30 +0900", "snippet": "Problem 1: Castingdouble a = 0;double* b = &amp;amp;a;double c = __a - *b; What shoud be filled in for the __? a. * b. &amp;amp; c. (nothing)Problem 2: Castingvoid f(int a, int* b, int* c){ __b = a * a; *c = a * a * a;} What shoud go in the __? a. * b. &amp;amp; c. void d. const* e. (nothing)Problem 3: Initializingvoid h(int const* vals, size_t n, int* even, int* odd){ __ __ for (size_t i = 0; i &amp;lt; n; i++&amp;gt;) { int* w; if (vals[i] % 2) w = even; else w = odd; (*w)++; }} What shoud be filled in for the __ in the following code? a. even = 0; odd = 0; b. even = &amp;amp;0; odd = &amp;amp;0; c. *even = 0; *odd = 0; d. &amp;amp;even = 0; &amp;amp;odd = 0;Problem 4: Castingchar* g(int const*, int);char a;int b; Which of the following would be legal ways to call the g function? a. a = *g(*b, b); b. &amp;amp;a = g(b, *b); c. &amp;amp;a = g(*b, b); d. a = *g(&amp;amp;b, b); e. a = *g(b, *b); f. &amp;amp;a = g(&amp;amp;b, b);AnswerQuestion 1The answer is c. There should exist the same types of variables in each side of = operator / = 연산자의 양변에는 동일한 타입의 변수가 있어야 합니다.In the line 3, the type of the left side of = operator is double. So, the type of the right side of = operator should be double. In that sense, __a - *b should be double type. We all know substraction bewtween doubles return double. So, __a and *b should be double type. b is pointer of double, so *b returns double. Finally, we just get __a should have type double. a is already initialized as double type, so we don’t need nothing in the blank.Question 2The answer is a. * in front of pointer to type returns type value. / type을 가리키는 포인터 앞에 *은 type값을 반환합니다.As we already discussed, in the line 3, the type of the right side of = operator is int. (Because int * int returns int.) So, the type of the left side of = opertator should be int. In that sense, __b should be int type. b is pointer of int, So we can expect *b become the int. So, the blank should be filled with *.Question 3The answer is c. When you initialize the value of pointer, use in way: *ptr = value; / 포인터의 값을 초기화할 때에는, *ptr = value; 형식으로!As we already discussed, in the line 3 and 4, the type of the right side of = operator is int. So the type of the left side of = operator shoud also be int. even and odd is pointer to int type. So, we can change even and odd as type int with * in front of them. These problems in this kind focus on the type of variables, so you don’t need to too focus and understand the logic of the code below. Just concentrate on the type and pointer of the variables. / 요런 문제들은 변수의 형식, 즉 타입에 집중하기 때문에 밑에 코드의 로직을 세세하게 살펴보지 않아도 괜찮다. 오로지 변수의 타입과 포인터에만 집중하자. 왜 b는 정답이 되지 못할까? 물론 = 연산자의 양변이 int의 포인터로 동일하지만, &amp;amp; 연산자는 변수 앞에만 붙을 수 있기 때문에 &amp;amp;0은 성립되지 못한다.Question 4The answer is d. &amp;amp;a = is impossible because we cannot modify the value of address of variable which is already initialiezed. / &amp;amp;a =는 불가능한 코드이다. 이미 지정된 변수의 주솟값을 고칠 수는 없기 때문이다.First of all, the return type of g is char*. And a is char. So, we need to add * in front of g in order to unify the types between = operator. So, we can conclude the answer is a = *g(...) form.Now let’s look in the arguments. The types are int const* and int. The first one seems serious. But we can know that if there is * in type, it is pointer whatever. So, int const* is pointer of int, and it need some address. So, we can easily notice that the argument should be (&amp;amp;b, b). Thus, the answer is a = *g(&amp;amp;b, b) The End!" }, { "title": "데이터 마이닝 00: Introduction to Data Mining", "url": "/posts/data-mining-00/", "categories": "Data Mining", "tags": "dm, lecture", "date": "2022-04-01 16:30:45 +0900", "snippet": "데이터 마이닝이란 무엇인가? 큰 DATASET에서 알려지지 않은, 유효한, 잠재적으로 쓸만한, 이해할만한 패턴의 발견 DATASET의 분석은 관찰되지 않은 관계를 찾아내고 데이터를 혁신적인 방법(이해가 쉽게 되고, 쓸만한)으로 정리 큰 데이터셋에서 반자동적인 분석을 통해 이러한 특성을 가진 패턴을 찾는다. Valid: 확실한 데이터인가? (노이즈는 아닌가?) Novel: 명확하지 않은 데이터를 명확하게! Useful: 그 요소들에 대하여 멋진 행동을 할 수 있는가 Understandable: 인간이 그 패턴을 보고 쉽게 이해할 수 있는가 이러한 패턴을 찾는 과정을 다른 말로 KDD라고 한다.KDDKDDKDD란 Knowledge Discovery in Database의 준말로, “데이터로 부터 유용한 지식을 발견하는 전 과정”을 말한다. KDD는 다음과 같은 과정으로 이루어진다. 문제 인식 (Problem Formulation) 데이터 수집 (Data Collection) 전처리 과정 (Pre-Processing, Cleaning) 이름이나 주소 값 수정, 동일한 value인데 다른 name이면 수정 (annual, yearly) 등, 중복 삭제, 잃어버린 데이터 채워넣기 (주로 평균값으로) 변형 (Transformation) 복잡한 데이터를 간단하게 재배열 마이닝 업무/방법 선택 (Choosing Minig Task and Mining Method) 결과 평가 및 시각화 (Result Evaluation and Visualization)KDD의 적용: 은행 업무, 고객 관리, 타켓 마케팅, 생산 및 판매 관리데이터 마이닝데이터 마이닝은 어떻게 쓰이는가? 문제 인식 데이터 마이닝 기술로 데이터 변형 → 유용한 정보 추출 정보 활용 결과 측정데이터 마이닝 과정 입력 이해 (어떤 형식의 입력이 들어오지?) 데이터셋 생성 (마이닝 알고리즘에 바로 먹일 수 있도록!) 흥미로운 특성 선택 데이터 전처리 (Pre-processing) 데이터 마이닝 Task와 특정 알고리즘 선택 결과 해석, 마음에 안 들면 2로 회귀데이터 마이닝의 필요성현실 세계의 데이터는 더럽다. 불완전성: 특성 값의 부재, 관심있는 어떤 특성의 부재, 이상한 데이터 포함 등 해결법: 잃어버린 값을 채워넣기 (평균, 최소, 최대 등) (Data Imputation) 노이즈: 한계 (Outlier) 밖에 존재하는 값 존재 (Error) 한계를 알아내고 Noisy Data를 날리기 비일관성: 동일한 값을 가지더라도 다른 방식으로 표현되는 데이터가 있음 알맞게 수정 쓰레기가 들어가면 쓰레기가 나온다. (Garbage In, Garbage Out) 질 좋은 판단은 질 좋은 데이터에서 나온다. 따라서 데이터 마이닝은 필수적이다!Data Mining Task크게 Prediction Tasks (Supervised Learning), Description Tasks (Unsupervised Learning)으로 나뉜다. Prediction은 입력 변수와 정답을 이용하여 알지 못하는 혹은 미래의 값을 예측/예상하는 것이고, Description은 정답 따위 없이 주어진 입력의 특성들을 이용해서 인간 친화적인, 인간이 잘 해석할 수 있는 패턴을 찾아 서술하는 작업이다. Prediction Tasks (Supervised Learning) Regression (예측, 회귀) Classification (분류) Description Tasks (Unsupervised Learning) Clustering (군집화) Association Rule Discovery (연관 규칙 추출) 데이터는 어떻게 생겼나? (어떤 Input이 들어가는가?)데이터셋은 두 개의 방향으로 이루어진 매트릭스로 표현할 수 있다. (벡터의 집합)데이터 매트릭스각 행은 데이터의 샘플을 나타내고, 각 열은 각 특성을 나타낸다. 만약 인간에 대한 데이터 매트릭스라면, 1행은 1번째 사람을 말하는 것이고, 2행은 2번째 사람을 말하는 것이다. 위 사진을 예시로 들자면, 150명에 대한 데이터 매트릭스이고, 5가지의 특성으로 정리되어 있다. 데이터 매트릭스 = 행 백터의 집합 (샘플 벡터의 집합) = 열 벡터의 집합 (특성 벡터의 집합) 요런거 물어보면 헷갈릴 수도 있으니 잘 정리해놓자! Number of Sample = Sample Size = n Number of Variables = Variables Size = p 행 벡터의 관점에서 차원 = p (한 행의 원소의 개수) 열 벡터의 관점에서 차원 = n (한 열의 원소의 개수) Dimensionality of Data = Length of Each Row Vector = 행 벡터의 길이 = p " }, { "title": "문제로 풀어보는 알고리즘 00장", "url": "/posts/algorithm-with-ps-00/", "categories": "Problem Solving, 문제로 풀어보는 알고리즘", "tags": "ps, book", "date": "2022-04-01 16:30:45 +0900", "snippet": "최댓값과 최솟값두 수를 받고 최대/최소를 반환하는 함수int max(int x, int y){ if (x &amp;gt; y) { return x; } return y;}int min(int x, int y){ if (x &amp;lt; y) { return x; } return y;}매크로 함수 작성 매크로 함수란? #define으로 함수를 미리 정의해두는 방법을 말한다. 주로 짧고 단순한, 많이 쓰이고 직관적인 구조를 취하는 함수는 매크로 함수로 정의한다. 삼항 연산자에 대하여 if (cond) A else B와 같은 코드는 삼항 연산자로 간단하게 적을 수 있다. : (cond?A:B)#define max(x, y) ((x)&amp;gt;(y)?x:y)#define min(x, y) ((x)&amp;lt;(y)?x:y) 단, 매크로 함수는 그저 글자를 바꿔치기 하는 역할을 하기에 실수할 수 있는 여지가 매우 높다. 매크로 함수를 이용해야하는 특별한 이유가 없다면 보통의 함수로 코드를 작성하자.세 수를 받고 최대/최소를 반환하는 함수int max(int x, int y, int z){ if (x &amp;gt; y) { if (x &amp;gt; z) { return x; } return z; } else { if (y &amp;gt; z) { return y; } return z; }}int max(int x, int y, int z){ if (x &amp;lt; y) { if (x &amp;lt; z) { return x; } return z; } else { if (y &amp;lt; z) { return y; } return z; }}배열의 최대값을 구하는 함수 배열을 인자로 전달할 때에는, 포인터 형식으로 준다. 단, 이럴 경우 배열의 길이를 알 수 없기에 배열의 길이 역시 함수의 인자로 전달해야 한다. 배열의 길이는 어떻게 계산할 수 있을까? 많은 방법이 있지만, HARD한 코드로는 sizeof arr / sizeof arr[0]으로 배열의 길이를 계산할 수 있다. 배열이나 문자열을 순회할 때에는 size_t 형식의 인덱스 변수를 선언하는 것이 국룰이다. 하지만 밑의 코드에서는 그냥 int를 썼다. (필자의 숙련도가 부족하니 너그러운 이해를 바란다.) 여담이지만, 위의 sizeof 연산자는 size_t를 반환한다.int max_arr(int *arr, int n){ int max = arr[0]; // 배열에 완전 탐색 시키면서 최대값을 업데이트 할 것임 for (int i = 1; i &amp;lt; n; i++) // i가 0부터 시작하지 않는 이유는? 정답은 밑에... { if (arr[i] &amp;gt; max) { max = arr[i]; // 순회하고 있는 원소가 기존의 최대값보다 크면 최대값 업데이트 } } return max;} 정답: 이미 max는 arr[0]이므로 밑의 if문을 통과하지 않을 것이 자명하다.두 변수의 값 바꾸기포인터를 이용하여 값을 swap하는 함수 main의 변수를 인자로 받을 때 call-by-value 방식을 사용하면 단순히 복사된 값을 사용하기 때문에 메모리도 낭비되고, 원본 값을 수정하지도 못한다. 따라서 많은 경우에 포인터로 인자를 넘기는 call-by-reference를 사용한다. call-by-reference의 장점은 무엇일까? main의 원본 변수 값에 접근하여 다이렉트로 수정할 수 있다. 여러 값을 처리(수정)해야되는 상황에서 유용하다. (이 경우 변수의 포인터를 이용하여 값들만 수정하고, 함수의 반환은 void형식(return ;)이다.) void swap(int *a, int *b){ int temp; temp = *a; *a = *b; *b = temp; return ;}배열의 두 원소를 swap하는 함수void swap_arr(int *arr, int i, int j){ int temp; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; return ;} 알고 있을 것 같기는 하지만… arr[i]는 *(arr + i)로 처리된다. 즉 결국 [] 연산자는 포인터 연산 + 값 뽑아오기 연산인 셈.배열 회전1차원 배열 회전 (오른쪽으로 한 칸)1차원 배열 회전 (오른쪽)void right_rotate(int *arr, int s, int t){ int last = arr[t]; for (int i = t; i &amp;gt; s; i--) // 왜 거꾸로 탐색할까? 밑에 빨간 영역 참고 { arr[i] = arr[i - 1]; // 요게 포인트! 밑에 자세한 설명... } arr[s] = last; return ;} 설명 : 위와 같은 상황에서, A = B라는 연산자를 바라볼 때 A는 나중 상황, B는 이전 상황으로 볼 수 있다. 즉, 위 그림에서 아래에 있는 배열은 A, 위에 있는 배열은 B인 셈이다. 이것을 먼저 고려한다면, 위 코드를 쉽게 작성할 수 있을 것이다. 이런 식으로 적으면 망한다! for (int i = s; i &amp;lt; t; i++){ arr[i + 1] = arr[i];} 왜 안 되는지는 스스로 고민해보고 읽기를… 이 코드가 정상적으로 작동하지 않는 이유는, arr[s + 1의 값을 arr[s]로 고친 이후에 arr[s + 2]의 값을 arr[s + 1]로 고치기 때문이다. 즉, 이후에 필요한 변수의 값이 이전에 수정되는, 배열의 모든 원소가 arr[s]가 되는 결과를 초래한다. 필자는 이미 한 번 실수했으니 독자들은 그러지 말기를…위와 같은 생각을 했지만, 그럴 경우 범위가 애매해진다. 따라서 last라는 변수에 따로 arr[t]를 저장하고, 후에 arr[s]에 대입해주자.1차원 배열 회전 (왼쪽으로 한 칸)1차원 배열 회전 (왼쪽)void left_rotate(int *arr, int s, int t){ int first = arr[s]; for (int i = s; i &amp;lt; t; i++) { arr[i] = arr[i + 1]; } arr[t] = first; return ;}위의 1차원 배열 회전 (오른쪽으로 한 칸)을 참고하면 쉽게 작성할 수 있다. 이때도 마찬가지로 배열의 모든 원소가 한 원소로 덮어써지지 않도록 주의하자.1차원 배열 회전 (오른쪽으로 k칸)위의 1차원 배열 회전 (오른쪽으로 한 칸)을 k번 반복하면 되지만, 너무 NAIVE하다. 용어에 익숙치 않은 독자들을 위해 소개하자면, NAIVE하다의 뜻은 순진하다, 무식하다 정도의 뜻이다. (솔직히 무식하게 k번 움직이는 것보다는 더 멋진 코드가 있을 것. 이는 직감적으로 알 수 있음.)따라서 General한 Form을 찾아보자! 우선 오른쪽으로 한 칸이니까 오른쪽에서 왼쪽으로 배열을 돌아야겠다는 생각이 든다. (이 문장이 이해가 안된다면, 위의 빨간 영역을 다시 읽어보자.)void right_rotate_k(int *arr, int s, int t, int k){ int *temp_arr; temp_arr = (int *)malloc(k * sizeof(int)); for (int i = 0; i &amp;lt; k; i++) { temp_arr[i] = arr[t - k + 1 + i]; } for (int j = t; j &amp;gt;= s + k; j--) { arr[j] = arr[j - k]; } for (int l = 0; l &amp;lt; k; l++) { arr[s + l] = temp_arr[l]; } return;}우선 k칸만큼 회전할 때 임시적으로 저장해야 하는 놈들은 k개가 된다. 이것을 배열로 저장하자. 사이즈가 달라지므로 동적할당을 사용했다. 동적할당에 대해 모르겠다면 지금은 메모리를 미리 찜해놓는다 정도의 개념으로 알아두자. 중요한 것은 위의 for문과 배열의 index가 왜 저렇게 쓰였는지 정확하게 이해하는 것이다.은행 대기 번호 관리 (큐/스택)큐(Queue)는 먼저 들어간 데이터가 먼저 나오는 자료구조를 말한다. (선입선출)큐큐에 데이터를 넣을 때에는 enqueue라는 용어를 쓰고, 데이터를 뽑아낼 때에는 dequeue라는 용어를 쓴다.배열로 큐 작성하기큐를 가장 HARD한 방법으로 코딩하는 방법은, head, tail를 정의하여 배열에서 큐의 컨테이너의 범위를 지정하는 것이다. 쉽게 말해 먼저 들어온 놈을 먼저 내보낼 것인데, 이를 위해 먼저 들어온 놈을 가리키는 index를 변수로 두고 (head), 나중에 들어온 놈을 가리키는 index를 변수로 두는 것이다. (tail)int queue[100]; // 왜 배열의 크기를 100개나 잡았을까? 정답은 밑의 빨간 영역에...int head = 0, tail = 0;void enqueue(int n) // 값이 큐에 들어옴{ if (tail - head == 8) // 큐의 사이즈가 8 이상이면 안 댐! { cout &amp;lt;&amp;lt; &quot;queue is full!&quot; &amp;lt;&amp;lt; endl; return ; } queue[tail] = n; // 큐에서 tail의 위치에 입력 데이터 저장 tail++; // tail 앞으로 한 칸 이동 return ;}int dequeue(){ if (tail - head == 0) { cout &amp;lt;&amp;lt; &quot;queue is empty!&quot; &amp;lt;&amp;lt; endl; return 0; } int r = queue[head]; // 현재 큐에서 head의 위치에 있는 데이터 반환, 왜 여기서 return을 하지 않았을까? 정답은 설명에... head++; // head 앞으로 한 칸 이동 return r;}int main(){ int input; while (true) { cin &amp;gt;&amp;gt; input; if (input == -1) { break; } else if (input == 0) { cout &amp;lt;&amp;lt; dequeue() &amp;lt;&amp;lt; endl; } else if (input &amp;gt; 0) { enqueue(input); } } return 0;} 책의 코드는 틀렸다? 그렇다. 책의 코드(28p~29p)는 장의 서문에서 제시한 예시 출력을 반환하지 못한다. 필자가 왜 그런지 열심히 고민해봤는데, 고민의 결과는 다음과 같다. 배열 queue의 크기가 8로 제한되어 있다. 변수 tail의 경우 입력한 횟수만큼 증가한다. (즉, 매우 큰 수가 대입될 수 있다.) 그.런.데! 명령어 queue[tail]이 존재한다. 따라서 이는 배열의 범위보다 큰 인덱스를 처리해야하는 문제로 귀결된다.필자는 이 문제를 배열 queue의 크기를 나름 큰 크기로 세팅하여 해결하였으나(queue[100]), 입력을 100번 이상 받으면 다시 문제가 발생할 것이다. (즉 queue[k]로 선언했다면 입력을 k번 이상 받을 경우 문제가 발생한다.) 따라서 이 문제를 해결할 멋진 방법을 필요로 하게 된다. 필자는 코드의 일관된 작성을 위하여 인덱스 값을 사용하고 인덱스 값을 업데이트 하는 방식으로 코드를 통일했다. 예컨데 enqueue(int n)와 dequeue()에서 queue[tail] = n; // 인덱스 값 사용 tail++; // 인덱스 값 업데이트 return ; int r = queue[head]; // 인덱스 값 사용 head++; // 인덱스 값 업데이트 return r; 이렇게 작성한 이유는, 책의 코드 같은 경우 head와 tail을 생성할 때 각각 head = 0, tail = -1과 같이 썼는데, 이렇게 쓸 경우 tail이 -1로 초기화된 것에 대하여 의문점을 가질 수 있고, 무엇보다 직관적이지 못하다. 또 별건 아니지만, 책에서는 queue_size 변수를 따로 만들어서 큐의 크기를 직접 조종하였지만, 위와 같이 일관된 코드를 작성하고 나면 queue_size 변수가 굳이 필요 없다는 것을 알게 된다. 그저 큐의 크기가 필요할 때마다 head - tail로 계산하면 되기 때문이다. 코드의 일관된 작성은 interpretable한 코드를 낼 수 있고, 이는 더 나은 코드를 찾을 수 있다는 점에서 contribution이 있다. 책에 있는 코드에 오타가 있어서 시간을 많이 빼았겨 분하고 화가 나는가? 책의 저자에게 너무 열을 내지 않도록 주의하자. 개발과 관련된 수많은 책의 리뷰를 보다보면, 이따금씩 코드의 오탈자로 저자를 나무라는 분노의 리뷰를 많이 보았다. 하지만 이게 당신의 실력 향상에 도움이 되는가? 전혀 도움 안된다. 물론, 오탈자의 정도가 심하다면 분명 수정이 필요하다. 하지만 코드를 직접 실행해보고, 디버깅해보며, 어떤 코드가 오류를 반환하고, 이를 어떻게 해결할 수 있는지 고민해보는 것도 좋은 공부가 될 것이다. (필자는 위의 빨간 영역을 적으며 많은 것을 배웠다.) 또한 책의 저자는 책의 서문에서 이미 오탈자에 대한 양해를 구하고 있으며, 코드 외적인 부분에서 내용을 훌륭하게 전달하고 있다고 생각한다. 그러니 포기하지 말고, 좀 더 공부해보자. :) (사실 이건 나 자신에게 하는 말과 같다.)원형 큐 작성하기배열로 큐 작성하기에서 빨간 영역으로 작성한 배열로 작성한 큐의 한계를 기억하는가? 그것은 바로, 배열 queue[k]로 선언했을 때 입력을 k번 이상 받을 경우 문제가 발생한다는 것이다. 왜냐하면 큐의 끝 인덱스를 나타내는 변수 tail은 입력 횟수에 비례하고, 입력 횟수는 제한이 없기에 배열의 크기보다 큰 인덱스가 들어갈 수 있기 때문이다.사실 배열로 작성한 큐의 문제는 그뿐만이 아니다. 메모리 효율성의 관점에서 엉망이다. 배열 queue에서 데이터 컨데이너로써 필요한 부분은 인덱스 head ~ tail이 전부이다. 그렇다면 0 ~ head, tail ~ 100은? (queue의 크기가 100이라고 전제하겠다.) 그냥 쓸데없는 부분이다. 이 사용되지도 않을 변수들을 위해서 메모리 상에 미리 자리를 맡아놓아야 한다니, 아깝지 않은가?이러한 관점에서 고민한 끝에, 새롭게 고안된 데이터 타입이 바로 원형 큐이다.원형 큐즉 위에서 구현한 배열로 만든 큐의 시작과 끝이 이어져있다고 생각하면 된다.#define QUEUE_CAPACITY 8 // 많이 쓰이므로 미리 정의해놓자int queue[100];int head = 0, tail = 0;int queue_size = 0;void enqueue(int n){ if (queue_size == 8) { cout &amp;lt;&amp;lt; &quot;queue is full!&quot; &amp;lt;&amp;lt; endl; return ; } queue[tail] = n; tail = (tail + 1) % QUEUE_CAPACITY; // tail 앞으로 한 칸 이동, 범위를 넘어가면 0으로 회귀 queue_size++; return;}int dequeue(){ if (queue_size == 0) { cout &amp;lt;&amp;lt; &quot;queue is empty!&quot; &amp;lt;&amp;lt; endl; return 0; } int r = queue[head]; head = (head + 1) % QUEUE_CAPACITY; // head 앞으로 한 칸 이동, 범위를 넘어가면 0으로 회귀 queue_size--; return r;}int main(){ int input; while (true) { cin &amp;gt;&amp;gt; input; if (input == -1) { break; } else if (input == 0) { cout &amp;lt;&amp;lt; dequeue() &amp;lt;&amp;lt; endl; } else if (input &amp;gt; 0) { enqueue(input); } } return 0;} 결국 원형 큐에서 가장 중요한 것은, 인덱스를 증가시키되, 범위를 초과하면 0으로 회귀시키는 것이다. 그리고 이러한 아이디어는 정확히 나머지 연산자(%)와 부합한다. 이 아이디어는 다양하게 활용되므로, 잘 기억해두자. tail = (tail + 1) % QUEUE_CAPACITY; head = (head + 1) % QUEUE_CAPACITY; 원형 큐에서 head와 tail을 인자로 받고, queue_size를 반환할 수 있는 함수를 짤 수는 없을까? 즉, 우리가 배열을 이용해서 큐를 구현할 때 사용했던 tail - head처럼 말이다. 결론부터 말하자면 조금 어려운 일인 것 같다. 필자는 밑의 코드까지 작성하고 포기했다. int queue_size(){ if (tail &amp;gt;= head) { return tail - head; } else { return QUEUE_CAPACITY - (head - tail) }} 왜 여기에서 포기하게 되었냐면, 디버깅을 해보니 “데이터가 큐에 꽉 찬 상황”과 “큐가 비어있는 상황”을 구분할 수 없었기 때문이다. 두 가지 상황 모두 head == tail 조건을 만족시킨다. (만약 책의 코드를 따랐다면, head = tail + 1 조건을 만족시킬 것이다.) 따라서 생각이 여기까지 도달했을 때, 다시 위로 올라가 int queue_size를 정의하고 enqueue(int n)과 dequeue()에 각각 queue_size++과 queue_size--를 추가했다… ㅠㅠ우리는 이렇게 원형 큐를 구현할 수 있었고, 이는 기존의 큐가 가진 문제점을 해결할 수 있다.배열로 스택 작성하기큐(Queue)는 먼저 들어간 데이터가 나중에 나오는, 즉 마지막에 들어간 데이터가 맨 처음에 나오는 자료구조를 말한다. (선입후출) (그러한 관점에서, 꽤 불공평하다.)스택스택에 데이터를 넣을 때에는 push라는 용어를 쓰고, 데이터를 뽑아낼 때에는 pop라는 용어를 쓴다.배열로 큐를 구현했을 때와 마찬가지로, 인덱스를 변수로 놓는 것이 구현의 첫 걸음이다. 넣는 인덱스와 뽑는 인덱스가 동일하므로, 이들을 변수 top으로 놓자.int stack[100];int top = 0; // top은 데이터가 들어왔을 때 놓을 인덱스로 놓자void push(int n){ if (top == 8) { cout &amp;lt;&amp;lt; &quot;queue is full!&quot; &amp;lt;&amp;lt; endl; return ; } stack[top] = n; top++; return;}int pop(){ if (top == 0) { cout &amp;lt;&amp;lt; &quot;queue is empty!&quot; &amp;lt;&amp;lt; endl; return 0; } int r = stack[top - 1]; top--; return r;}int main(){ int input; while (true) { cin &amp;gt;&amp;gt; input; if (input == -1) { break; } else if (input == 0) { cout &amp;lt;&amp;lt; pop() &amp;lt;&amp;lt; endl; } else if (input &amp;gt; 0) { push(input); } } return 0;}요런 식으로 구현할 수 있다. (큐보다 훨씬 쉽다.) 위 경우 스택의 크기는 top이라는 General한 방법으로 구할 수 있다. 쉽기야 하지만, 한 가지 고려해야할 것은 인덱스 변수 top이 “push(n)할 때 입력된 데이터가 들어갈 자리의 인덱스”인지 “pop()할 때 뽑힐 데이터의 인덱스”인지 구분하는 것이다. 위 코드의 경우 전자를 따랐다.일반적인 데이터 타입을 다룰 수 있는 (원형) 큐 작성하기캬… 어려운 거 나왔다. C언어에서 일반적인 데이터 타입을 다룰 수 있는 방법은 무엇일까? C언어에서 모든 데이터 타입의 변수를 다룰 수 있는 방법은 없지만, 모든 데이터 타입의 포인터를 저장할 수는 있다. 그것은 바로 void *이다. void *는 데이터의 주소값(포인터)을 대입할 수 있는데, 대입하거나 대입될 때 자동으로 형 변환이 일어난다. int* x = ptr; // ptr &amp;lt;- void* 타입 따라서 타입 코드만 조금 수정하면 될 것 같다. ㅋㅋㅋ 방금 해보고 왔는데 안된다. C++에서는 기본적으로 void*를 임의의 다른 포인터형으로 자동 변환해주지 않는다. 수동으로 형변환을 해줘야 한다. (자동 변환해주는 거는 C에서의 이야기이다. 이러한 차이는 C++과 C의 미세한 차이에 속한다.) int* x = (int *)ptr; // ptr &amp;lt;- void* 타입 #define QUEUE_CAPACITY 8void* queue[100]; // 큐의 원소는 각 값의 포인터int head = 0, tail = 0;int queue_size = 0;void enqueue(void* n) // enqueue시 인자는 값의 포인터{ if (queue_size == 8) { cout &amp;lt;&amp;lt; &quot;queue is full!&quot; &amp;lt;&amp;lt; endl; return ; } queue[tail] = n; tail = (tail + 1) % QUEUE_CAPACITY; queue_size++; return;}void* dequeue() // 반환 값은 포인터 형식이므로 void*{ if (queue_size == 0) { cout &amp;lt;&amp;lt; &quot;queue is empty!&quot; &amp;lt;&amp;lt; endl; return nullptr; } void* r = queue[head]; // 반환 값은 포인터 형식이므로 void* head = (head + 1) % QUEUE_CAPACITY; queue_size--; return r;} 사실 여기까지 적었지만, 필자는 main()을 어떻게 적어야 할지 잘 모르겠다. int main(){ int input; while (true) { cin &amp;gt;&amp;gt; input; if (input == -1) { break; } else if (input == 0) { int *r = (int*)(dequeue()); cout &amp;lt;&amp;lt; *r &amp;lt;&amp;lt; endl; } else if (input &amp;gt; 0) { int x = input; // 여기서 문제가 생긴듯 enqueue(&amp;amp;x); } } return 0;} 여기까지 적었는데, 문제가 있다. 실행해보면 dequeue를 호출할 때마다 동일한 값만 나온다. 그리고 이것은 아마도 11번째 행 else if (input &amp;gt; 0)영역이 문제인 것 같은데, 내가 기대했던 것은 매번 저 영역을 지날 때마다 int x를 실행하여 이름은 x로 똑같지만 포인터 값이 항상 다른 변수를 만드는 것이었지만, 실행해보니 항상 똑같은 값이 들어가는 모양이다. (실제로 배열의 내부를 확인해보니 그렇더라) 이를 해결할 수 있는 다른 멋진 방법이 필요해보인다. 다음에 이 글을 보면 해결할 수 있기를! 연결 리스트우리는 위에서 배열로 큐를 구현하는 것의 문제점과 한계를 직면했고, 그에 대한 해결책으로 원형 큐를 배웠다. 하지만, 해결책은 원형 큐만이 있는 것은 아니다. 우리가 배울 기법은 이 문제의 해결책이 되는데, 그것은 바로 연결 리스트이다.연결 리스트의 노드는 key 변수와 다음 노드를 가리키는 포인터 struct _node *next로 이루어져 있다. (포인터의 형은 구현 방식에 따라 차이가 있지만, 책에서는 struct 타입으로 구현하였다.) head는 첫번째 노드를 가리키고, tail은 마지막 노드를 가리킨다. 그리고 노드 tail의 포인터 값은 아무것도 가리키지 않기에, NULL을 가진다. (아래 그림을 보면 이해가 쉬울 것이다) 장점 연결리스트는 배열과 다르게 중간에 노드를 삽입하거나 제거할 때 원소를 밀어내거나 이동시킬 필요가 없다. 그냥 연결을 끊고 새로운 노드와 붙이거나, 한 노드의 양 연결을 끊고 이 노드를 배재시킨 후 연결시키면 끝나기 때문이다. 단점 그러나 임의의 위치에 있는 (i번째) 원소를 찾는 과정이 오래 걸린다. 완전 탐색을 수행하기 때문.연결리스트의 종류로는 이중 연결 리스트 (Doubly Linked List), 원형 연결 리스트 (Circular Linked List) 등이 있는데, 요 책에서는 단일 연결 리스트(Singular Linked List)만 다룬다.연결 리스트연결 리스트로 큐 작성하기struct _node{ int key; struct _node *next;};typedef struct _node node_t;node_t *head = NULL, *tail = NULL; // head와 tail은 첫 노드와 마지막 노드를 가리키는 포인터, 초기는 NULLvoid insert_node(int n) // 숫자 n을 리스트에 추가할 것{ node_t *new_node = (node_t*)malloc(sizeof(node_t)); new_node-&amp;gt;key = n; new_node-&amp;gt;next = NULL; // 추가된 노드가 가리켜야할 노드는? 아무것도 가리키지 않으므로 NULL! if (head == NULL) // head가 NULL이라면, 즉 지금 들어온 노드가 첫 번째 입력이라면 { head = new_node; tail = new_node; } else { tail-&amp;gt;next = new_node; tail = new_node; }}int delete_node(){ node_t *node; // 출력 노드의 포인터 int r; if (head == NULL) // 지금 리스트가 비어있다면 return -1; node = head; // 출력 노드 = head head = head-&amp;gt;next; // head 노드는 출력되므로(사라지므로), head 노드는 그 다음 노드로 업데이트 됨 if (head == NULL) // 다음 노드가 NULL이라면, 즉 위에서 뽑았던 노드가 마지막 노드였다면 tail = NULL; // 리스트가 텅 빈 것이므로 tail을 NULL로 바꾸기 r = node-&amp;gt;key; free(node); return r;}int main(){ int input; while (true) { cin &amp;gt;&amp;gt; input; if (input == -1) { break; } else if (input == 0) { cout &amp;lt;&amp;lt; delete_node() &amp;lt;&amp;lt; endl; } else if (input &amp;gt; 0) { insert_node(input); } } return 0;}연결 리스트 구현에 있어 몇 가지 유의해야하는 점들이 있다. 구조체(struct)에 대하여 구조체란 여러 변수들의 묶음으로 이해하면 편하다. 그리고 여러 변수들을 묶었기에, 이 구조체를 새로운 타입으로써 바라볼 수 있다. 구조체 선언: 구조체 _node는 정수형 변수 key와 구조체 _node의 포인터 변수 next의 묶음이다. struct _node{ int key; struct _node *next;}; 구조체를 간지나게 쓰기: struct _node *node보다는 node_t *node가 더 간결하고 간지난다. 따라서 typedef를 통해서 구조체의 이름을 새로운 타입으로 정의하자. typedef struct _node node_t; // struct _node는 node_t 구조체의 값 접근: 구조체 자체가 주어졌는지, 구조체의 포인터가 주어졌는지에 따라 다르다. 차이를 잘 기억해놓자. // 구조체가 주어짐struct A a;a.x = 1;a.y = 2; // 요런 . 연산자로 접근// 구조체의 포인터가 주어짐struct A *a;a-&amp;gt;x = 1;a-&amp;gt;y = 2; // 요런 -&amp;gt; 연산자로 접근 head와 tail은 위 배열에서 보았던 방법과 같이 인덱스로 사용된 것이 아니고 포인터로 사용된다. 따라서 리스트가 빈 상황에서 꼭 아래와 같이 NULL로 초기화를 시켜주어야 한다. 그리고 리스트가 빈 상황은 delete_node() 안에서 head의 값을 업데이트할 때 head의 다음 노드를 가리키는 포인터가 NULL 인 것으로 알 수 있다. head = head-&amp;gt;next; // head 노드는 출력되므로(사라지므로), head 노드는 그 다음 노드로 업데이트 됨if (head == NULL) // 다음 노드가 NULL이라면, 즉 위에서 뽑았던 노드가 마지막 노드였다면{ tail = NULL; // 리스트가 텅 빈 것이므로 tail을 NULL로 바꾸기} 이 연결 리스트는 대기번호를 몇 개까지 받을 수 있을까?코드를 작성하여 확인해보자.int main(){ double cnt = 0; while (true) { cout &amp;lt;&amp;lt; cnt &amp;lt;&amp;lt; endl; try { insert_node(1); } catch(const std::exception&amp;amp; e) { std::cerr &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; &#39;\\n&#39;; break; } cnt++; } return 0;} 지금 코드를 짜서 실행시키고 있긴 한데… 아직도 안 끝났다 ㅋㅋ 결과 해석은 나중에 써야할 듯.연결 리스트를 이용하여 양쪽 끝에서 삽입과 삭제가 일어나는 Double Ended Queue 작성하기 (작성 중)끝에 추가했던 코드를 맨 앞에 추가하는 코드로 수정하면 될 것 같다.struct _node{ int key; struct _node *next;};typedef struct _node node_t;node_t *head = NULL, *tail = NULL; // head와 tail은 첫 노드와 마지막 노드를 가리키는 포인터, 초기는 NULLvoid insert_front_node(int n) // 숫자 n을 리스트에 추가할 것{ node_t *new_node = (node_t*)malloc(sizeof(node_t)); new_node-&amp;gt;key = n; new_node-&amp;gt;next = head; // 추가된 노드가 가리켜야할 노드는? 맨 앞이 되므로 head! if (head == NULL) // head가 NULL이라면, 즉 지금 들어온 노드가 첫 번째 입력이라면 { head = new_node; tail = new_node; } else { head = new_node; }}// 밑에 놈을 어떻게 적지? 정확히는, tail을 뽑고 tail을 어떻게 업데이트하지?int delete_front_node(){ node_t *node; // 출력 노드의 포인터 int r; if (head == NULL) // 지금 리스트가 비어있다면 return -1; node = head; // 출력 노드 = head head = head-&amp;gt;next; // head 노드는 출력되므로(사라지므로), head 노드는 그 다음 노드로 업데이트 됨 if (head == NULL) // 다음 노드가 NULL이라면, 즉 위에서 뽑았던 노드가 마지막 노드였다면 tail = NULL; // 리스트가 텅 빈 것이므로 tail을 NULL로 바꾸기 r = node-&amp;gt;key; free(node); return r;}void insert_node(int n) // 숫자 n을 리스트에 추가할 것{ node_t *new_node = (node_t*)malloc(sizeof(node_t)); new_node-&amp;gt;key = n; new_node-&amp;gt;next = NULL; // 추가된 노드가 가리켜야할 노드는? 아무것도 가리키지 않으므로 NULL! if (head == NULL) // head가 NULL이라면, 즉 지금 들어온 노드가 첫 번째 입력이라면 { head = new_node; tail = new_node; } else { tail-&amp;gt;next = new_node; tail = new_node; }}int delete_node(){ node_t *node; // 출력 노드의 포인터 int r; if (head == NULL) // 지금 리스트가 비어있다면 return -1; node = head; // 출력 노드 = head head = head-&amp;gt;next; // head 노드는 출력되므로(사라지므로), head 노드는 그 다음 노드로 업데이트 됨 if (head == NULL) // 다음 노드가 NULL이라면, 즉 위에서 뽑았던 노드가 마지막 노드였다면 tail = NULL; // 리스트가 텅 빈 것이므로 tail을 NULL로 바꾸기 r = node-&amp;gt;key; free(node); return r;}int main(){ int input; while (true) { cin &amp;gt;&amp;gt; input; if (input == -1) { break; } else if (input == 0) { cout &amp;lt;&amp;lt; delete_node() &amp;lt;&amp;lt; endl; } else if (input &amp;gt; 0) { insert_node(input); } } return 0;} 오늘은 여기까지! (2022/4/3 16시)" }, { "title": "Hello World!", "url": "/posts/hello-world/", "categories": "Blog", "tags": "etc", "date": "2022-03-31 22:36:09 +0900", "snippet": "Hello World, this is my first blog post.I hope you love my writing!안녕 세상, 이것은 저의 블로그 첫 포스팅입니다.제 글을 즐기시길 바래요!" } ]
